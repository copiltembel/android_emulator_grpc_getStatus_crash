// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: emulator_controller.proto
// Original file comments:
// Copyright (C) 2018 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Note that if you add/remove methods in this file you must update
// the metrics sql as well ./android/scripts/gen-grpc-sql.py
//
// Please group deleted methods in a block including the date (MM/DD/YY)
// it was removed. This enables us to easily keep metrics around after removal
//
// List of deleted methods
// rpc iWasDeleted (03/12/12)
// ...
#ifndef GRPC_emulator_5fcontroller_2eproto__INCLUDED
#define GRPC_emulator_5fcontroller_2eproto__INCLUDED

#include "emulator_controller.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace android {
namespace emulation {
namespace control {

// An EmulatorController service lets you control the emulator.
// Note that this is currently an experimental feature, and that the
// service definition might change without notice. Use at your own risk!
//
// We use the following rough conventions:
//
// streamXXX --> streams values XXX (usually for emulator lifetime). Values
//               are updated as soon as they become available.
// getXXX    --> gets a single value XXX
// setXXX    --> sets a single value XXX, does not returning state, these
//               usually have an observable lasting side effect.
// sendXXX   --> send a single event XXX, possibly returning state information.
//               android usually responds to these events.
class EmulatorController final {
 public:
  static constexpr char const* service_full_name() {
    return "android.emulation.control.EmulatorController";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // set/get/stream the sensor data
    std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::SensorValue>> streamSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::SensorValue>>(streamSensorRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::SensorValue>> AsyncstreamSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::SensorValue>>(AsyncstreamSensorRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::SensorValue>> PrepareAsyncstreamSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::SensorValue>>(PrepareAsyncstreamSensorRaw(context, request, cq));
    }
    virtual ::grpc::Status getSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::android::emulation::control::SensorValue* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::SensorValue>> AsyncgetSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::SensorValue>>(AsyncgetSensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::SensorValue>> PrepareAsyncgetSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::SensorValue>>(PrepareAsyncgetSensorRaw(context, request, cq));
    }
    virtual ::grpc::Status setSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetSensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetSensorRaw(context, request, cq));
    }
    // set/get/stream the physical model, this is likely the one you are
    // looking for when you wish to modify the device state.
    virtual ::grpc::Status setPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetPhysicalModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetPhysicalModelRaw(context, request, cq));
    }
    virtual ::grpc::Status getPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::android::emulation::control::PhysicalModelValue* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhysicalModelValue>> AsyncgetPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhysicalModelValue>>(AsyncgetPhysicalModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhysicalModelValue>> PrepareAsyncgetPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhysicalModelValue>>(PrepareAsyncgetPhysicalModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::PhysicalModelValue>> streamPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::PhysicalModelValue>>(streamPhysicalModelRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::PhysicalModelValue>> AsyncstreamPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::PhysicalModelValue>>(AsyncstreamPhysicalModelRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::PhysicalModelValue>> PrepareAsyncstreamPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::PhysicalModelValue>>(PrepareAsyncstreamPhysicalModelRaw(context, request, cq));
    }
    // Atomically set/get the current primary clipboard data.
    virtual ::grpc::Status setClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetClipboardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetClipboardRaw(context, request, cq));
    }
    virtual ::grpc::Status getClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::ClipData* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::ClipData>> AsyncgetClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::ClipData>>(AsyncgetClipboardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::ClipData>> PrepareAsyncgetClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::ClipData>>(PrepareAsyncgetClipboardRaw(context, request, cq));
    }
    // Streams the current data on the clipboard. This will immediately produce
    // a result with the current state of the clipboard after which the stream
    // will block and wait until a new clip event is available from the guest.
    // Calling the setClipboard method above will not result in generating a clip
    // event. It is possible to lose clipboard events if the clipboard updates
    // very rapidly.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::ClipData>> streamClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::ClipData>>(streamClipboardRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::ClipData>> AsyncstreamClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::ClipData>>(AsyncstreamClipboardRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::ClipData>> PrepareAsyncstreamClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::ClipData>>(PrepareAsyncstreamClipboardRaw(context, request, cq));
    }
    // Set/get the battery to the given state.
    virtual ::grpc::Status setBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetBatteryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetBatteryRaw(context, request, cq));
    }
    virtual ::grpc::Status getBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::BatteryState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::BatteryState>> AsyncgetBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::BatteryState>>(AsyncgetBatteryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::BatteryState>> PrepareAsyncgetBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::BatteryState>>(PrepareAsyncgetBatteryRaw(context, request, cq));
    }
    // Set the state of the gps, gps support will only work
    // properly if:
    //
    // - no location ui is active. That is the emulator
    //   is launched in headless mode (-no-window) or the location
    //   ui is disabled (-no-location-ui).
    // - the passiveUpdate is set to false. Setting this to false
    //   will disable/break the LocationUI.
    //
    // Keep in mind that android usually only samples the gps at 1 hz.
    virtual ::grpc::Status setGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetGpsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetGpsRaw(context, request, cq));
    }
    // Gets the latest gps state as delivered by the setGps call, or location ui
    // if active.
    //
    // Note: this is not necessarily the actual gps coordinate visible at the
    // time, due to gps sample frequency (usually 1hz).
    virtual ::grpc::Status getGps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::GpsState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::GpsState>> AsyncgetGps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::GpsState>>(AsyncgetGpsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::GpsState>> PrepareAsyncgetGps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::GpsState>>(PrepareAsyncgetGpsRaw(context, request, cq));
    }
    // Simulate a touch event on the finger print sensor.
    virtual ::grpc::Status sendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsendFingerprintRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsendFingerprintRaw(context, request, cq));
    }
    // Send a keyboard event. Translating the event.
    virtual ::grpc::Status sendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsendKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsendKeyRaw(context, request, cq));
    }
    // Send touch/mouse events. Note that mouse events can be simulated
    // by touch events.
    virtual ::grpc::Status sendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsendTouchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsendTouchRaw(context, request, cq));
    }
    virtual ::grpc::Status sendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsendMouseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsendMouseRaw(context, request, cq));
    }
    // Make a phone call.
    virtual ::grpc::Status sendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::android::emulation::control::PhoneResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>> AsyncsendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>>(AsyncsendPhoneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>> PrepareAsyncsendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>>(PrepareAsyncsendPhoneRaw(context, request, cq));
    }
    // Sends an sms message to the emulator.
    virtual ::grpc::Status sendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::android::emulation::control::PhoneResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>> AsyncsendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>>(AsyncsendSmsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>> PrepareAsyncsendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>>(PrepareAsyncsendSmsRaw(context, request, cq));
    }
    // Retrieve the status of the emulator. This will contain general
    // hardware information, and whether the device has booted or not.
    virtual ::grpc::Status getStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::EmulatorStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::EmulatorStatus>> AsyncgetStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::EmulatorStatus>>(AsyncgetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::EmulatorStatus>> PrepareAsyncgetStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::EmulatorStatus>>(PrepareAsyncgetStatusRaw(context, request, cq));
    }
    // Gets an individual screenshot in the desired format.
    //
    // The image will be scaled to the desired ImageFormat, while maintaining
    // the aspect ratio. The returned image will never exceed the provided width
    // and height. Not setting the width or height (i.e. they are 0) will result
    // in using the device width and height.
    //
    // The resulting image will be properly oriented and can be displayed
    // directly without post processing. For example, if the device has a
    // 1080x1920 screen and is in landscape mode and called with no width or
    // height parameter, it will return an 1920x1080 image.
    //
    // This method will return an empty image if the display is not visible.
    virtual ::grpc::Status getScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::android::emulation::control::Image* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::Image>> AsyncgetScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::Image>>(AsyncgetScreenshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::Image>> PrepareAsyncgetScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::Image>>(PrepareAsyncgetScreenshotRaw(context, request, cq));
    }
    // Streams a series of screenshots in the desired format.
    // A new frame will be delivered whenever the device produces a new frame.
    // (Beware that this can produce a significant amount of data, and that
    // certain translations are (png transform) can be costly).
    //
    // If the requested display is not visible it will send a single empty image
    // and wait start producing images once the display becomes active, again
    // producing a single empty image when the display becomes inactive.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::Image>> streamScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::Image>>(streamScreenshotRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::Image>> AsyncstreamScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::Image>>(AsyncstreamScreenshotRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::Image>> PrepareAsyncstreamScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::Image>>(PrepareAsyncstreamScreenshotRaw(context, request, cq));
    }
    // Streams a series of audio packets in the desired format.
    // A new frame will be delivered whenever the emulated device
    // produces a new audio frame.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::AudioPacket>> streamAudio(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::AudioPacket>>(streamAudioRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::AudioPacket>> AsyncstreamAudio(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::AudioPacket>>(AsyncstreamAudioRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::AudioPacket>> PrepareAsyncstreamAudio(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::AudioPacket>>(PrepareAsyncstreamAudioRaw(context, request, cq));
    }
    // Returns the last 128Kb of logcat output from the emulator
    // Note that parsed logcat messages are only available after L (Api >23).
    // it is possible that the logcat buffer gets overwritten, or falls behind.
    virtual ::grpc::Status getLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::android::emulation::control::LogMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::LogMessage>> AsyncgetLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::LogMessage>>(AsyncgetLogcatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::LogMessage>> PrepareAsyncgetLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::LogMessage>>(PrepareAsyncgetLogcatRaw(context, request, cq));
    }
    // Streams the logcat output from the emulator. The first call
    // can retrieve up to 128Kb. This call will not return.
    // Note that parsed logcat messages are only available after L (Api >23)
    // it is possible that the logcat buffer gets overwritten, or falls behind.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::LogMessage>> streamLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::android::emulation::control::LogMessage>>(streamLogcatRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::LogMessage>> AsyncstreamLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::LogMessage>>(AsyncstreamLogcatRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::LogMessage>> PrepareAsyncstreamLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::LogMessage>>(PrepareAsyncstreamLogcatRaw(context, request, cq));
    }
    // Transition the virtual machine to the desired state. Note that
    // some states are only observable. For example you cannot transition
    // to the error state.
    virtual ::grpc::Status setVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetVmStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetVmStateRaw(context, request, cq));
    }
    // Gets the state of the virtual machine.
    virtual ::grpc::Status getVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::VmRunState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::VmRunState>> AsyncgetVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::VmRunState>>(AsyncgetVmStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::VmRunState>> PrepareAsyncgetVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::VmRunState>>(PrepareAsyncgetVmStateRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // set/get/stream the sensor data
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void streamSensor(::grpc::ClientContext* context, ::android::emulation::control::SensorValue* request, ::grpc::ClientReadReactor< ::android::emulation::control::SensorValue>* reactor) = 0;
      #else
      virtual void streamSensor(::grpc::ClientContext* context, ::android::emulation::control::SensorValue* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::SensorValue>* reactor) = 0;
      #endif
      virtual void getSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::android::emulation::control::SensorValue* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::SensorValue* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::android::emulation::control::SensorValue* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::android::emulation::control::SensorValue* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::SensorValue* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::SensorValue* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void setSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // set/get/stream the physical model, this is likely the one you are
      // looking for when you wish to modify the device state.
      virtual void setPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::android::emulation::control::PhysicalModelValue* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhysicalModelValue* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::android::emulation::control::PhysicalModelValue* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::android::emulation::control::PhysicalModelValue* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhysicalModelValue* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhysicalModelValue* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void streamPhysicalModel(::grpc::ClientContext* context, ::android::emulation::control::PhysicalModelValue* request, ::grpc::ClientReadReactor< ::android::emulation::control::PhysicalModelValue>* reactor) = 0;
      #else
      virtual void streamPhysicalModel(::grpc::ClientContext* context, ::android::emulation::control::PhysicalModelValue* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::PhysicalModelValue>* reactor) = 0;
      #endif
      // Atomically set/get the current primary clipboard data.
      virtual void setClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::ClipData* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::ClipData* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::ClipData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::ClipData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::ClipData* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::ClipData* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Streams the current data on the clipboard. This will immediately produce
      // a result with the current state of the clipboard after which the stream
      // will block and wait until a new clip event is available from the guest.
      // Calling the setClipboard method above will not result in generating a clip
      // event. It is possible to lose clipboard events if the clipboard updates
      // very rapidly.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void streamClipboard(::grpc::ClientContext* context, ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::android::emulation::control::ClipData>* reactor) = 0;
      #else
      virtual void streamClipboard(::grpc::ClientContext* context, ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::ClipData>* reactor) = 0;
      #endif
      // Set/get the battery to the given state.
      virtual void setBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::BatteryState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::BatteryState* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::BatteryState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::BatteryState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::BatteryState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::BatteryState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Set the state of the gps, gps support will only work
      // properly if:
      //
      // - no location ui is active. That is the emulator
      //   is launched in headless mode (-no-window) or the location
      //   ui is disabled (-no-location-ui).
      // - the passiveUpdate is set to false. Setting this to false
      //   will disable/break the LocationUI.
      //
      // Keep in mind that android usually only samples the gps at 1 hz.
      virtual void setGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Gets the latest gps state as delivered by the setGps call, or location ui
      // if active.
      //
      // Note: this is not necessarily the actual gps coordinate visible at the
      // time, due to gps sample frequency (usually 1hz).
      virtual void getGps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::GpsState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::GpsState* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getGps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::GpsState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getGps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::GpsState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::GpsState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::GpsState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Simulate a touch event on the finger print sensor.
      virtual void sendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sendFingerprint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendFingerprint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendFingerprint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Send a keyboard event. Translating the event.
      virtual void sendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sendKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Send touch/mouse events. Note that mouse events can be simulated
      // by touch events.
      virtual void sendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sendTouch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendTouch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendTouch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void sendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sendMouse(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendMouse(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendMouse(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Make a phone call.
      virtual void sendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall* request, ::android::emulation::control::PhoneResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sendPhone(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall* request, ::android::emulation::control::PhoneResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall* request, ::android::emulation::control::PhoneResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendPhone(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendPhone(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Sends an sms message to the emulator.
      virtual void sendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage* request, ::android::emulation::control::PhoneResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sendSms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage* request, ::android::emulation::control::PhoneResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage* request, ::android::emulation::control::PhoneResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void sendSms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void sendSms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Retrieve the status of the emulator. This will contain general
      // hardware information, and whether the device has booted or not.
      virtual void getStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::EmulatorStatus* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::EmulatorStatus* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::EmulatorStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::EmulatorStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::EmulatorStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::EmulatorStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Gets an individual screenshot in the desired format.
      //
      // The image will be scaled to the desired ImageFormat, while maintaining
      // the aspect ratio. The returned image will never exceed the provided width
      // and height. Not setting the width or height (i.e. they are 0) will result
      // in using the device width and height.
      //
      // The resulting image will be properly oriented and can be displayed
      // directly without post processing. For example, if the device has a
      // 1080x1920 screen and is in landscape mode and called with no width or
      // height parameter, it will return an 1920x1080 image.
      //
      // This method will return an empty image if the display is not visible.
      virtual void getScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat* request, ::android::emulation::control::Image* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getScreenshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::Image* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat* request, ::android::emulation::control::Image* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat* request, ::android::emulation::control::Image* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getScreenshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::Image* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getScreenshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::Image* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Streams a series of screenshots in the desired format.
      // A new frame will be delivered whenever the device produces a new frame.
      // (Beware that this can produce a significant amount of data, and that
      // certain translations are (png transform) can be costly).
      //
      // If the requested display is not visible it will send a single empty image
      // and wait start producing images once the display becomes active, again
      // producing a single empty image when the display becomes inactive.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void streamScreenshot(::grpc::ClientContext* context, ::android::emulation::control::ImageFormat* request, ::grpc::ClientReadReactor< ::android::emulation::control::Image>* reactor) = 0;
      #else
      virtual void streamScreenshot(::grpc::ClientContext* context, ::android::emulation::control::ImageFormat* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::Image>* reactor) = 0;
      #endif
      // Streams a series of audio packets in the desired format.
      // A new frame will be delivered whenever the emulated device
      // produces a new audio frame.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void streamAudio(::grpc::ClientContext* context, ::android::emulation::control::AudioFormat* request, ::grpc::ClientReadReactor< ::android::emulation::control::AudioPacket>* reactor) = 0;
      #else
      virtual void streamAudio(::grpc::ClientContext* context, ::android::emulation::control::AudioFormat* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::AudioPacket>* reactor) = 0;
      #endif
      // Returns the last 128Kb of logcat output from the emulator
      // Note that parsed logcat messages are only available after L (Api >23).
      // it is possible that the logcat buffer gets overwritten, or falls behind.
      virtual void getLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage* request, ::android::emulation::control::LogMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getLogcat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::LogMessage* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage* request, ::android::emulation::control::LogMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage* request, ::android::emulation::control::LogMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getLogcat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::LogMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getLogcat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::LogMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Streams the logcat output from the emulator. The first call
      // can retrieve up to 128Kb. This call will not return.
      // Note that parsed logcat messages are only available after L (Api >23)
      // it is possible that the logcat buffer gets overwritten, or falls behind.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void streamLogcat(::grpc::ClientContext* context, ::android::emulation::control::LogMessage* request, ::grpc::ClientReadReactor< ::android::emulation::control::LogMessage>* reactor) = 0;
      #else
      virtual void streamLogcat(::grpc::ClientContext* context, ::android::emulation::control::LogMessage* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::LogMessage>* reactor) = 0;
      #endif
      // Transition the virtual machine to the desired state. Note that
      // some states are only observable. For example you cannot transition
      // to the error state.
      virtual void setVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Gets the state of the virtual machine.
      virtual void getVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::VmRunState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::VmRunState* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::VmRunState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::VmRunState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::VmRunState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::VmRunState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::android::emulation::control::SensorValue>* streamSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::SensorValue>* AsyncstreamSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::SensorValue>* PrepareAsyncstreamSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::SensorValue>* AsyncgetSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::SensorValue>* PrepareAsyncgetSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhysicalModelValue>* AsyncgetPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhysicalModelValue>* PrepareAsyncgetPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::android::emulation::control::PhysicalModelValue>* streamPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::PhysicalModelValue>* AsyncstreamPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::PhysicalModelValue>* PrepareAsyncstreamPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetClipboardRaw(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetClipboardRaw(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::ClipData>* AsyncgetClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::ClipData>* PrepareAsyncgetClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::android::emulation::control::ClipData>* streamClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::ClipData>* AsyncstreamClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::ClipData>* PrepareAsyncstreamClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetBatteryRaw(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetBatteryRaw(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::BatteryState>* AsyncgetBatteryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::BatteryState>* PrepareAsyncgetBatteryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetGpsRaw(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetGpsRaw(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::GpsState>* AsyncgetGpsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::GpsState>* PrepareAsyncgetGpsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsendFingerprintRaw(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsendFingerprintRaw(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsendKeyRaw(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsendKeyRaw(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsendTouchRaw(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsendTouchRaw(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsendMouseRaw(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsendMouseRaw(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>* AsyncsendPhoneRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>* PrepareAsyncsendPhoneRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>* AsyncsendSmsRaw(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::PhoneResponse>* PrepareAsyncsendSmsRaw(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::EmulatorStatus>* AsyncgetStatusRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::EmulatorStatus>* PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::Image>* AsyncgetScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::Image>* PrepareAsyncgetScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::android::emulation::control::Image>* streamScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::Image>* AsyncstreamScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::Image>* PrepareAsyncstreamScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::android::emulation::control::AudioPacket>* streamAudioRaw(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::AudioPacket>* AsyncstreamAudioRaw(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::AudioPacket>* PrepareAsyncstreamAudioRaw(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::LogMessage>* AsyncgetLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::LogMessage>* PrepareAsyncgetLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::android::emulation::control::LogMessage>* streamLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::LogMessage>* AsyncstreamLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::android::emulation::control::LogMessage>* PrepareAsyncstreamLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetVmStateRaw(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetVmStateRaw(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::VmRunState>* AsyncgetVmStateRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::android::emulation::control::VmRunState>* PrepareAsyncgetVmStateRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::SensorValue>> streamSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::SensorValue>>(streamSensorRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::SensorValue>> AsyncstreamSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::SensorValue>>(AsyncstreamSensorRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::SensorValue>> PrepareAsyncstreamSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::SensorValue>>(PrepareAsyncstreamSensorRaw(context, request, cq));
    }
    ::grpc::Status getSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::android::emulation::control::SensorValue* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::SensorValue>> AsyncgetSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::SensorValue>>(AsyncgetSensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::SensorValue>> PrepareAsyncgetSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::SensorValue>>(PrepareAsyncgetSensorRaw(context, request, cq));
    }
    ::grpc::Status setSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetSensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetSensorRaw(context, request, cq));
    }
    ::grpc::Status setPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetPhysicalModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetPhysicalModelRaw(context, request, cq));
    }
    ::grpc::Status getPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::android::emulation::control::PhysicalModelValue* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhysicalModelValue>> AsyncgetPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhysicalModelValue>>(AsyncgetPhysicalModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhysicalModelValue>> PrepareAsyncgetPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhysicalModelValue>>(PrepareAsyncgetPhysicalModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::PhysicalModelValue>> streamPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::PhysicalModelValue>>(streamPhysicalModelRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::PhysicalModelValue>> AsyncstreamPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::PhysicalModelValue>>(AsyncstreamPhysicalModelRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::PhysicalModelValue>> PrepareAsyncstreamPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::PhysicalModelValue>>(PrepareAsyncstreamPhysicalModelRaw(context, request, cq));
    }
    ::grpc::Status setClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetClipboardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetClipboardRaw(context, request, cq));
    }
    ::grpc::Status getClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::ClipData* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::ClipData>> AsyncgetClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::ClipData>>(AsyncgetClipboardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::ClipData>> PrepareAsyncgetClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::ClipData>>(PrepareAsyncgetClipboardRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::ClipData>> streamClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::ClipData>>(streamClipboardRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::ClipData>> AsyncstreamClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::ClipData>>(AsyncstreamClipboardRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::ClipData>> PrepareAsyncstreamClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::ClipData>>(PrepareAsyncstreamClipboardRaw(context, request, cq));
    }
    ::grpc::Status setBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetBatteryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetBatteryRaw(context, request, cq));
    }
    ::grpc::Status getBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::BatteryState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::BatteryState>> AsyncgetBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::BatteryState>>(AsyncgetBatteryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::BatteryState>> PrepareAsyncgetBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::BatteryState>>(PrepareAsyncgetBatteryRaw(context, request, cq));
    }
    ::grpc::Status setGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetGpsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetGpsRaw(context, request, cq));
    }
    ::grpc::Status getGps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::GpsState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::GpsState>> AsyncgetGps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::GpsState>>(AsyncgetGpsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::GpsState>> PrepareAsyncgetGps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::GpsState>>(PrepareAsyncgetGpsRaw(context, request, cq));
    }
    ::grpc::Status sendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsendFingerprintRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsendFingerprintRaw(context, request, cq));
    }
    ::grpc::Status sendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsendKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsendKeyRaw(context, request, cq));
    }
    ::grpc::Status sendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsendTouchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsendTouchRaw(context, request, cq));
    }
    ::grpc::Status sendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsendMouseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsendMouseRaw(context, request, cq));
    }
    ::grpc::Status sendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::android::emulation::control::PhoneResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>> AsyncsendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>>(AsyncsendPhoneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>> PrepareAsyncsendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>>(PrepareAsyncsendPhoneRaw(context, request, cq));
    }
    ::grpc::Status sendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::android::emulation::control::PhoneResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>> AsyncsendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>>(AsyncsendSmsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>> PrepareAsyncsendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>>(PrepareAsyncsendSmsRaw(context, request, cq));
    }
    ::grpc::Status getStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::EmulatorStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::EmulatorStatus>> AsyncgetStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::EmulatorStatus>>(AsyncgetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::EmulatorStatus>> PrepareAsyncgetStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::EmulatorStatus>>(PrepareAsyncgetStatusRaw(context, request, cq));
    }
    ::grpc::Status getScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::android::emulation::control::Image* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::Image>> AsyncgetScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::Image>>(AsyncgetScreenshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::Image>> PrepareAsyncgetScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::Image>>(PrepareAsyncgetScreenshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::Image>> streamScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::Image>>(streamScreenshotRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::Image>> AsyncstreamScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::Image>>(AsyncstreamScreenshotRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::Image>> PrepareAsyncstreamScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::Image>>(PrepareAsyncstreamScreenshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::AudioPacket>> streamAudio(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::AudioPacket>>(streamAudioRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::AudioPacket>> AsyncstreamAudio(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::AudioPacket>>(AsyncstreamAudioRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::AudioPacket>> PrepareAsyncstreamAudio(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::AudioPacket>>(PrepareAsyncstreamAudioRaw(context, request, cq));
    }
    ::grpc::Status getLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::android::emulation::control::LogMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::LogMessage>> AsyncgetLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::LogMessage>>(AsyncgetLogcatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::LogMessage>> PrepareAsyncgetLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::LogMessage>>(PrepareAsyncgetLogcatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::LogMessage>> streamLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::android::emulation::control::LogMessage>>(streamLogcatRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::LogMessage>> AsyncstreamLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::LogMessage>>(AsyncstreamLogcatRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::LogMessage>> PrepareAsyncstreamLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::android::emulation::control::LogMessage>>(PrepareAsyncstreamLogcatRaw(context, request, cq));
    }
    ::grpc::Status setVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetVmStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetVmStateRaw(context, request, cq));
    }
    ::grpc::Status getVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::android::emulation::control::VmRunState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::VmRunState>> AsyncgetVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::VmRunState>>(AsyncgetVmStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::VmRunState>> PrepareAsyncgetVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::android::emulation::control::VmRunState>>(PrepareAsyncgetVmStateRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void streamSensor(::grpc::ClientContext* context, ::android::emulation::control::SensorValue* request, ::grpc::ClientReadReactor< ::android::emulation::control::SensorValue>* reactor) override;
      #else
      void streamSensor(::grpc::ClientContext* context, ::android::emulation::control::SensorValue* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::SensorValue>* reactor) override;
      #endif
      void getSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::android::emulation::control::SensorValue* response, std::function<void(::grpc::Status)>) override;
      void getSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::SensorValue* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::android::emulation::control::SensorValue* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::android::emulation::control::SensorValue* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::SensorValue* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::SensorValue* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void setSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setSensor(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setSensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void setPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::android::emulation::control::PhysicalModelValue* response, std::function<void(::grpc::Status)>) override;
      void getPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhysicalModelValue* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::android::emulation::control::PhysicalModelValue* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getPhysicalModel(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::android::emulation::control::PhysicalModelValue* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhysicalModelValue* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getPhysicalModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhysicalModelValue* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void streamPhysicalModel(::grpc::ClientContext* context, ::android::emulation::control::PhysicalModelValue* request, ::grpc::ClientReadReactor< ::android::emulation::control::PhysicalModelValue>* reactor) override;
      #else
      void streamPhysicalModel(::grpc::ClientContext* context, ::android::emulation::control::PhysicalModelValue* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::PhysicalModelValue>* reactor) override;
      #endif
      void setClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setClipboard(::grpc::ClientContext* context, const ::android::emulation::control::ClipData* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::ClipData* response, std::function<void(::grpc::Status)>) override;
      void getClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::ClipData* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::ClipData* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getClipboard(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::ClipData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::ClipData* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getClipboard(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::ClipData* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void streamClipboard(::grpc::ClientContext* context, ::google::protobuf::Empty* request, ::grpc::ClientReadReactor< ::android::emulation::control::ClipData>* reactor) override;
      #else
      void streamClipboard(::grpc::ClientContext* context, ::google::protobuf::Empty* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::ClipData>* reactor) override;
      #endif
      void setBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setBattery(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::BatteryState* response, std::function<void(::grpc::Status)>) override;
      void getBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::BatteryState* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::BatteryState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getBattery(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::BatteryState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::BatteryState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getBattery(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::BatteryState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void setGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setGps(::grpc::ClientContext* context, const ::android::emulation::control::GpsState* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getGps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::GpsState* response, std::function<void(::grpc::Status)>) override;
      void getGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::GpsState* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getGps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::GpsState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getGps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::GpsState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::GpsState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getGps(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::GpsState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void sendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void sendFingerprint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendFingerprint(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendFingerprint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendFingerprint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void sendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void sendKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendKey(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendKey(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void sendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void sendTouch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendTouch(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendTouch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendTouch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void sendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void sendMouse(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendMouse(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendMouse(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendMouse(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void sendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall* request, ::android::emulation::control::PhoneResponse* response, std::function<void(::grpc::Status)>) override;
      void sendPhone(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall* request, ::android::emulation::control::PhoneResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendPhone(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall* request, ::android::emulation::control::PhoneResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendPhone(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendPhone(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void sendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage* request, ::android::emulation::control::PhoneResponse* response, std::function<void(::grpc::Status)>) override;
      void sendSms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage* request, ::android::emulation::control::PhoneResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendSms(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage* request, ::android::emulation::control::PhoneResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void sendSms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void sendSms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::PhoneResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::EmulatorStatus* response, std::function<void(::grpc::Status)>) override;
      void getStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::EmulatorStatus* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::EmulatorStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::EmulatorStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::EmulatorStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::EmulatorStatus* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat* request, ::android::emulation::control::Image* response, std::function<void(::grpc::Status)>) override;
      void getScreenshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::Image* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat* request, ::android::emulation::control::Image* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getScreenshot(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat* request, ::android::emulation::control::Image* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getScreenshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::Image* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getScreenshot(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::Image* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void streamScreenshot(::grpc::ClientContext* context, ::android::emulation::control::ImageFormat* request, ::grpc::ClientReadReactor< ::android::emulation::control::Image>* reactor) override;
      #else
      void streamScreenshot(::grpc::ClientContext* context, ::android::emulation::control::ImageFormat* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::Image>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void streamAudio(::grpc::ClientContext* context, ::android::emulation::control::AudioFormat* request, ::grpc::ClientReadReactor< ::android::emulation::control::AudioPacket>* reactor) override;
      #else
      void streamAudio(::grpc::ClientContext* context, ::android::emulation::control::AudioFormat* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::AudioPacket>* reactor) override;
      #endif
      void getLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage* request, ::android::emulation::control::LogMessage* response, std::function<void(::grpc::Status)>) override;
      void getLogcat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::LogMessage* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage* request, ::android::emulation::control::LogMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getLogcat(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage* request, ::android::emulation::control::LogMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getLogcat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::LogMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getLogcat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::LogMessage* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void streamLogcat(::grpc::ClientContext* context, ::android::emulation::control::LogMessage* request, ::grpc::ClientReadReactor< ::android::emulation::control::LogMessage>* reactor) override;
      #else
      void streamLogcat(::grpc::ClientContext* context, ::android::emulation::control::LogMessage* request, ::grpc::experimental::ClientReadReactor< ::android::emulation::control::LogMessage>* reactor) override;
      #endif
      void setVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setVmState(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::VmRunState* response, std::function<void(::grpc::Status)>) override;
      void getVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::VmRunState* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::VmRunState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getVmState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::VmRunState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::VmRunState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getVmState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::android::emulation::control::VmRunState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::android::emulation::control::SensorValue>* streamSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::SensorValue>* AsyncstreamSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::SensorValue>* PrepareAsyncstreamSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::SensorValue>* AsyncgetSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::SensorValue>* PrepareAsyncgetSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetSensorRaw(::grpc::ClientContext* context, const ::android::emulation::control::SensorValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhysicalModelValue>* AsyncgetPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhysicalModelValue>* PrepareAsyncgetPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::android::emulation::control::PhysicalModelValue>* streamPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::PhysicalModelValue>* AsyncstreamPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::PhysicalModelValue>* PrepareAsyncstreamPhysicalModelRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhysicalModelValue& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetClipboardRaw(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetClipboardRaw(::grpc::ClientContext* context, const ::android::emulation::control::ClipData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::ClipData>* AsyncgetClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::ClipData>* PrepareAsyncgetClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::android::emulation::control::ClipData>* streamClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::ClipData>* AsyncstreamClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::ClipData>* PrepareAsyncstreamClipboardRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetBatteryRaw(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetBatteryRaw(::grpc::ClientContext* context, const ::android::emulation::control::BatteryState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::BatteryState>* AsyncgetBatteryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::BatteryState>* PrepareAsyncgetBatteryRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetGpsRaw(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetGpsRaw(::grpc::ClientContext* context, const ::android::emulation::control::GpsState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::GpsState>* AsyncgetGpsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::GpsState>* PrepareAsyncgetGpsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsendFingerprintRaw(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsendFingerprintRaw(::grpc::ClientContext* context, const ::android::emulation::control::Fingerprint& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsendKeyRaw(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsendKeyRaw(::grpc::ClientContext* context, const ::android::emulation::control::KeyboardEvent& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsendTouchRaw(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsendTouchRaw(::grpc::ClientContext* context, const ::android::emulation::control::TouchEvent& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsendMouseRaw(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsendMouseRaw(::grpc::ClientContext* context, const ::android::emulation::control::MouseEvent& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>* AsyncsendPhoneRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>* PrepareAsyncsendPhoneRaw(::grpc::ClientContext* context, const ::android::emulation::control::PhoneCall& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>* AsyncsendSmsRaw(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::PhoneResponse>* PrepareAsyncsendSmsRaw(::grpc::ClientContext* context, const ::android::emulation::control::SmsMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::EmulatorStatus>* AsyncgetStatusRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::EmulatorStatus>* PrepareAsyncgetStatusRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::Image>* AsyncgetScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::Image>* PrepareAsyncgetScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::android::emulation::control::Image>* streamScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::Image>* AsyncstreamScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::Image>* PrepareAsyncstreamScreenshotRaw(::grpc::ClientContext* context, const ::android::emulation::control::ImageFormat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::android::emulation::control::AudioPacket>* streamAudioRaw(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::AudioPacket>* AsyncstreamAudioRaw(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::AudioPacket>* PrepareAsyncstreamAudioRaw(::grpc::ClientContext* context, const ::android::emulation::control::AudioFormat& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::LogMessage>* AsyncgetLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::LogMessage>* PrepareAsyncgetLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::android::emulation::control::LogMessage>* streamLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::LogMessage>* AsyncstreamLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::android::emulation::control::LogMessage>* PrepareAsyncstreamLogcatRaw(::grpc::ClientContext* context, const ::android::emulation::control::LogMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetVmStateRaw(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetVmStateRaw(::grpc::ClientContext* context, const ::android::emulation::control::VmRunState& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::VmRunState>* AsyncgetVmStateRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::android::emulation::control::VmRunState>* PrepareAsyncgetVmStateRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_streamSensor_;
    const ::grpc::internal::RpcMethod rpcmethod_getSensor_;
    const ::grpc::internal::RpcMethod rpcmethod_setSensor_;
    const ::grpc::internal::RpcMethod rpcmethod_setPhysicalModel_;
    const ::grpc::internal::RpcMethod rpcmethod_getPhysicalModel_;
    const ::grpc::internal::RpcMethod rpcmethod_streamPhysicalModel_;
    const ::grpc::internal::RpcMethod rpcmethod_setClipboard_;
    const ::grpc::internal::RpcMethod rpcmethod_getClipboard_;
    const ::grpc::internal::RpcMethod rpcmethod_streamClipboard_;
    const ::grpc::internal::RpcMethod rpcmethod_setBattery_;
    const ::grpc::internal::RpcMethod rpcmethod_getBattery_;
    const ::grpc::internal::RpcMethod rpcmethod_setGps_;
    const ::grpc::internal::RpcMethod rpcmethod_getGps_;
    const ::grpc::internal::RpcMethod rpcmethod_sendFingerprint_;
    const ::grpc::internal::RpcMethod rpcmethod_sendKey_;
    const ::grpc::internal::RpcMethod rpcmethod_sendTouch_;
    const ::grpc::internal::RpcMethod rpcmethod_sendMouse_;
    const ::grpc::internal::RpcMethod rpcmethod_sendPhone_;
    const ::grpc::internal::RpcMethod rpcmethod_sendSms_;
    const ::grpc::internal::RpcMethod rpcmethod_getStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_getScreenshot_;
    const ::grpc::internal::RpcMethod rpcmethod_streamScreenshot_;
    const ::grpc::internal::RpcMethod rpcmethod_streamAudio_;
    const ::grpc::internal::RpcMethod rpcmethod_getLogcat_;
    const ::grpc::internal::RpcMethod rpcmethod_streamLogcat_;
    const ::grpc::internal::RpcMethod rpcmethod_setVmState_;
    const ::grpc::internal::RpcMethod rpcmethod_getVmState_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // set/get/stream the sensor data
    virtual ::grpc::Status streamSensor(::grpc::ServerContext* context, const ::android::emulation::control::SensorValue* request, ::grpc::ServerWriter< ::android::emulation::control::SensorValue>* writer);
    virtual ::grpc::Status getSensor(::grpc::ServerContext* context, const ::android::emulation::control::SensorValue* request, ::android::emulation::control::SensorValue* response);
    virtual ::grpc::Status setSensor(::grpc::ServerContext* context, const ::android::emulation::control::SensorValue* request, ::google::protobuf::Empty* response);
    // set/get/stream the physical model, this is likely the one you are
    // looking for when you wish to modify the device state.
    virtual ::grpc::Status setPhysicalModel(::grpc::ServerContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status getPhysicalModel(::grpc::ServerContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::android::emulation::control::PhysicalModelValue* response);
    virtual ::grpc::Status streamPhysicalModel(::grpc::ServerContext* context, const ::android::emulation::control::PhysicalModelValue* request, ::grpc::ServerWriter< ::android::emulation::control::PhysicalModelValue>* writer);
    // Atomically set/get the current primary clipboard data.
    virtual ::grpc::Status setClipboard(::grpc::ServerContext* context, const ::android::emulation::control::ClipData* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status getClipboard(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::ClipData* response);
    // Streams the current data on the clipboard. This will immediately produce
    // a result with the current state of the clipboard after which the stream
    // will block and wait until a new clip event is available from the guest.
    // Calling the setClipboard method above will not result in generating a clip
    // event. It is possible to lose clipboard events if the clipboard updates
    // very rapidly.
    virtual ::grpc::Status streamClipboard(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpc::ServerWriter< ::android::emulation::control::ClipData>* writer);
    // Set/get the battery to the given state.
    virtual ::grpc::Status setBattery(::grpc::ServerContext* context, const ::android::emulation::control::BatteryState* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status getBattery(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::BatteryState* response);
    // Set the state of the gps, gps support will only work
    // properly if:
    //
    // - no location ui is active. That is the emulator
    //   is launched in headless mode (-no-window) or the location
    //   ui is disabled (-no-location-ui).
    // - the passiveUpdate is set to false. Setting this to false
    //   will disable/break the LocationUI.
    //
    // Keep in mind that android usually only samples the gps at 1 hz.
    virtual ::grpc::Status setGps(::grpc::ServerContext* context, const ::android::emulation::control::GpsState* request, ::google::protobuf::Empty* response);
    // Gets the latest gps state as delivered by the setGps call, or location ui
    // if active.
    //
    // Note: this is not necessarily the actual gps coordinate visible at the
    // time, due to gps sample frequency (usually 1hz).
    virtual ::grpc::Status getGps(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::GpsState* response);
    // Simulate a touch event on the finger print sensor.
    virtual ::grpc::Status sendFingerprint(::grpc::ServerContext* context, const ::android::emulation::control::Fingerprint* request, ::google::protobuf::Empty* response);
    // Send a keyboard event. Translating the event.
    virtual ::grpc::Status sendKey(::grpc::ServerContext* context, const ::android::emulation::control::KeyboardEvent* request, ::google::protobuf::Empty* response);
    // Send touch/mouse events. Note that mouse events can be simulated
    // by touch events.
    virtual ::grpc::Status sendTouch(::grpc::ServerContext* context, const ::android::emulation::control::TouchEvent* request, ::google::protobuf::Empty* response);
    virtual ::grpc::Status sendMouse(::grpc::ServerContext* context, const ::android::emulation::control::MouseEvent* request, ::google::protobuf::Empty* response);
    // Make a phone call.
    virtual ::grpc::Status sendPhone(::grpc::ServerContext* context, const ::android::emulation::control::PhoneCall* request, ::android::emulation::control::PhoneResponse* response);
    // Sends an sms message to the emulator.
    virtual ::grpc::Status sendSms(::grpc::ServerContext* context, const ::android::emulation::control::SmsMessage* request, ::android::emulation::control::PhoneResponse* response);
    // Retrieve the status of the emulator. This will contain general
    // hardware information, and whether the device has booted or not.
    virtual ::grpc::Status getStatus(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::EmulatorStatus* response);
    // Gets an individual screenshot in the desired format.
    //
    // The image will be scaled to the desired ImageFormat, while maintaining
    // the aspect ratio. The returned image will never exceed the provided width
    // and height. Not setting the width or height (i.e. they are 0) will result
    // in using the device width and height.
    //
    // The resulting image will be properly oriented and can be displayed
    // directly without post processing. For example, if the device has a
    // 1080x1920 screen and is in landscape mode and called with no width or
    // height parameter, it will return an 1920x1080 image.
    //
    // This method will return an empty image if the display is not visible.
    virtual ::grpc::Status getScreenshot(::grpc::ServerContext* context, const ::android::emulation::control::ImageFormat* request, ::android::emulation::control::Image* response);
    // Streams a series of screenshots in the desired format.
    // A new frame will be delivered whenever the device produces a new frame.
    // (Beware that this can produce a significant amount of data, and that
    // certain translations are (png transform) can be costly).
    //
    // If the requested display is not visible it will send a single empty image
    // and wait start producing images once the display becomes active, again
    // producing a single empty image when the display becomes inactive.
    virtual ::grpc::Status streamScreenshot(::grpc::ServerContext* context, const ::android::emulation::control::ImageFormat* request, ::grpc::ServerWriter< ::android::emulation::control::Image>* writer);
    // Streams a series of audio packets in the desired format.
    // A new frame will be delivered whenever the emulated device
    // produces a new audio frame.
    virtual ::grpc::Status streamAudio(::grpc::ServerContext* context, const ::android::emulation::control::AudioFormat* request, ::grpc::ServerWriter< ::android::emulation::control::AudioPacket>* writer);
    // Returns the last 128Kb of logcat output from the emulator
    // Note that parsed logcat messages are only available after L (Api >23).
    // it is possible that the logcat buffer gets overwritten, or falls behind.
    virtual ::grpc::Status getLogcat(::grpc::ServerContext* context, const ::android::emulation::control::LogMessage* request, ::android::emulation::control::LogMessage* response);
    // Streams the logcat output from the emulator. The first call
    // can retrieve up to 128Kb. This call will not return.
    // Note that parsed logcat messages are only available after L (Api >23)
    // it is possible that the logcat buffer gets overwritten, or falls behind.
    virtual ::grpc::Status streamLogcat(::grpc::ServerContext* context, const ::android::emulation::control::LogMessage* request, ::grpc::ServerWriter< ::android::emulation::control::LogMessage>* writer);
    // Transition the virtual machine to the desired state. Note that
    // some states are only observable. For example you cannot transition
    // to the error state.
    virtual ::grpc::Status setVmState(::grpc::ServerContext* context, const ::android::emulation::control::VmRunState* request, ::google::protobuf::Empty* response);
    // Gets the state of the virtual machine.
    virtual ::grpc::Status getVmState(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::android::emulation::control::VmRunState* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_streamSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_streamSensor() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_streamSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::SensorValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamSensor(::grpc::ServerContext* context, ::android::emulation::control::SensorValue* request, ::grpc::ServerAsyncWriter< ::android::emulation::control::SensorValue>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getSensor() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_getSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::android::emulation::control::SensorValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSensor(::grpc::ServerContext* context, ::android::emulation::control::SensorValue* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::SensorValue>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setSensor() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_setSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetSensor(::grpc::ServerContext* context, ::android::emulation::control::SensorValue* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setPhysicalModel() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_setPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetPhysicalModel(::grpc::ServerContext* context, ::android::emulation::control::PhysicalModelValue* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getPhysicalModel() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_getPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::android::emulation::control::PhysicalModelValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetPhysicalModel(::grpc::ServerContext* context, ::android::emulation::control::PhysicalModelValue* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::PhysicalModelValue>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_streamPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_streamPhysicalModel() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_streamPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::PhysicalModelValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamPhysicalModel(::grpc::ServerContext* context, ::android::emulation::control::PhysicalModelValue* request, ::grpc::ServerAsyncWriter< ::android::emulation::control::PhysicalModelValue>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setClipboard() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_setClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClipboard(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ClipData* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetClipboard(::grpc::ServerContext* context, ::android::emulation::control::ClipData* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getClipboard() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_getClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::ClipData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetClipboard(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::ClipData>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_streamClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_streamClipboard() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_streamClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::ClipData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamClipboard(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncWriter< ::android::emulation::control::ClipData>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setBattery() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_setBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setBattery(::grpc::ServerContext* /*context*/, const ::android::emulation::control::BatteryState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetBattery(::grpc::ServerContext* context, ::android::emulation::control::BatteryState* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getBattery() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_getBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getBattery(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::BatteryState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetBattery(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::BatteryState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setGps() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_setGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGps(::grpc::ServerContext* /*context*/, const ::android::emulation::control::GpsState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetGps(::grpc::ServerContext* context, ::android::emulation::control::GpsState* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getGps() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_getGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::GpsState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetGps(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::GpsState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sendFingerprint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendFingerprint() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_sendFingerprint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFingerprint(::grpc::ServerContext* /*context*/, const ::android::emulation::control::Fingerprint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendFingerprint(::grpc::ServerContext* context, ::android::emulation::control::Fingerprint* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sendKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendKey() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_sendKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendKey(::grpc::ServerContext* /*context*/, const ::android::emulation::control::KeyboardEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendKey(::grpc::ServerContext* context, ::android::emulation::control::KeyboardEvent* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sendTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendTouch() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_sendTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTouch(::grpc::ServerContext* /*context*/, const ::android::emulation::control::TouchEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendTouch(::grpc::ServerContext* context, ::android::emulation::control::TouchEvent* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sendMouse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendMouse() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_sendMouse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendMouse(::grpc::ServerContext* /*context*/, const ::android::emulation::control::MouseEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendMouse(::grpc::ServerContext* context, ::android::emulation::control::MouseEvent* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sendPhone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendPhone() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_sendPhone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendPhone(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhoneCall* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendPhone(::grpc::ServerContext* context, ::android::emulation::control::PhoneCall* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::PhoneResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sendSms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sendSms() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_sendSms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendSms(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SmsMessage* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendSms(::grpc::ServerContext* context, ::android::emulation::control::SmsMessage* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::PhoneResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getStatus() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::EmulatorStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatus(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::EmulatorStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getScreenshot() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_getScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::android::emulation::control::Image* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetScreenshot(::grpc::ServerContext* context, ::android::emulation::control::ImageFormat* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::Image>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_streamScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_streamScreenshot() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_streamScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamScreenshot(::grpc::ServerContext* context, ::android::emulation::control::ImageFormat* request, ::grpc::ServerAsyncWriter< ::android::emulation::control::Image>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(21, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_streamAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_streamAudio() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_streamAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAudio(::grpc::ServerContext* /*context*/, const ::android::emulation::control::AudioFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::AudioPacket>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamAudio(::grpc::ServerContext* context, ::android::emulation::control::AudioFormat* request, ::grpc::ServerAsyncWriter< ::android::emulation::control::AudioPacket>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getLogcat() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_getLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::android::emulation::control::LogMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLogcat(::grpc::ServerContext* context, ::android::emulation::control::LogMessage* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::LogMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_streamLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_streamLogcat() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_streamLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::LogMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamLogcat(::grpc::ServerContext* context, ::android::emulation::control::LogMessage* request, ::grpc::ServerAsyncWriter< ::android::emulation::control::LogMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(24, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setVmState() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_setVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setVmState(::grpc::ServerContext* /*context*/, const ::android::emulation::control::VmRunState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetVmState(::grpc::ServerContext* context, ::android::emulation::control::VmRunState* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getVmState() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_getVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVmState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::VmRunState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetVmState(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::android::emulation::control::VmRunState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_streamSensor<WithAsyncMethod_getSensor<WithAsyncMethod_setSensor<WithAsyncMethod_setPhysicalModel<WithAsyncMethod_getPhysicalModel<WithAsyncMethod_streamPhysicalModel<WithAsyncMethod_setClipboard<WithAsyncMethod_getClipboard<WithAsyncMethod_streamClipboard<WithAsyncMethod_setBattery<WithAsyncMethod_getBattery<WithAsyncMethod_setGps<WithAsyncMethod_getGps<WithAsyncMethod_sendFingerprint<WithAsyncMethod_sendKey<WithAsyncMethod_sendTouch<WithAsyncMethod_sendMouse<WithAsyncMethod_sendPhone<WithAsyncMethod_sendSms<WithAsyncMethod_getStatus<WithAsyncMethod_getScreenshot<WithAsyncMethod_streamScreenshot<WithAsyncMethod_streamAudio<WithAsyncMethod_getLogcat<WithAsyncMethod_streamLogcat<WithAsyncMethod_setVmState<WithAsyncMethod_getVmState<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_streamSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_streamSensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::android::emulation::control::SensorValue, ::android::emulation::control::SensorValue>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::SensorValue* request) { return this->streamSensor(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_streamSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::SensorValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::android::emulation::control::SensorValue>* streamSensor(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::android::emulation::control::SensorValue>* streamSensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getSensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::SensorValue, ::android::emulation::control::SensorValue>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::SensorValue* request, ::android::emulation::control::SensorValue* response) { return this->getSensor(context, request, response); }));}
    void SetMessageAllocatorFor_getSensor(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::SensorValue, ::android::emulation::control::SensorValue>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::SensorValue, ::android::emulation::control::SensorValue>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::android::emulation::control::SensorValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getSensor(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::android::emulation::control::SensorValue* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getSensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::android::emulation::control::SensorValue* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setSensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::SensorValue, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::SensorValue* request, ::google::protobuf::Empty* response) { return this->setSensor(context, request, response); }));}
    void SetMessageAllocatorFor_setSensor(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::SensorValue, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::SensorValue, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setSensor(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setSensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setPhysicalModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::PhysicalModelValue, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::PhysicalModelValue* request, ::google::protobuf::Empty* response) { return this->setPhysicalModel(context, request, response); }));}
    void SetMessageAllocatorFor_setPhysicalModel(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::PhysicalModelValue, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::PhysicalModelValue, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setPhysicalModel(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setPhysicalModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getPhysicalModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::PhysicalModelValue, ::android::emulation::control::PhysicalModelValue>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::PhysicalModelValue* request, ::android::emulation::control::PhysicalModelValue* response) { return this->getPhysicalModel(context, request, response); }));}
    void SetMessageAllocatorFor_getPhysicalModel(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::PhysicalModelValue, ::android::emulation::control::PhysicalModelValue>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::PhysicalModelValue, ::android::emulation::control::PhysicalModelValue>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::android::emulation::control::PhysicalModelValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getPhysicalModel(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::android::emulation::control::PhysicalModelValue* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getPhysicalModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::android::emulation::control::PhysicalModelValue* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_streamPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_streamPhysicalModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::android::emulation::control::PhysicalModelValue, ::android::emulation::control::PhysicalModelValue>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::PhysicalModelValue* request) { return this->streamPhysicalModel(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_streamPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::PhysicalModelValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::android::emulation::control::PhysicalModelValue>* streamPhysicalModel(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::android::emulation::control::PhysicalModelValue>* streamPhysicalModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setClipboard() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::ClipData, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::ClipData* request, ::google::protobuf::Empty* response) { return this->setClipboard(context, request, response); }));}
    void SetMessageAllocatorFor_setClipboard(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::ClipData, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::ClipData, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClipboard(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ClipData* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setClipboard(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::ClipData* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setClipboard(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::ClipData* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getClipboard() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::ClipData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::android::emulation::control::ClipData* response) { return this->getClipboard(context, request, response); }));}
    void SetMessageAllocatorFor_getClipboard(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::android::emulation::control::ClipData>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::ClipData>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::ClipData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getClipboard(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::ClipData* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getClipboard(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::ClipData* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_streamClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_streamClipboard() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::google::protobuf::Empty, ::android::emulation::control::ClipData>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request) { return this->streamClipboard(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_streamClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::ClipData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::android::emulation::control::ClipData>* streamClipboard(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::android::emulation::control::ClipData>* streamClipboard(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setBattery() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::BatteryState, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::BatteryState* request, ::google::protobuf::Empty* response) { return this->setBattery(context, request, response); }));}
    void SetMessageAllocatorFor_setBattery(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::BatteryState, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::BatteryState, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setBattery(::grpc::ServerContext* /*context*/, const ::android::emulation::control::BatteryState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setBattery(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::BatteryState* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setBattery(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::BatteryState* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getBattery() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::BatteryState>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::android::emulation::control::BatteryState* response) { return this->getBattery(context, request, response); }));}
    void SetMessageAllocatorFor_getBattery(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::android::emulation::control::BatteryState>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::BatteryState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getBattery(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::BatteryState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getBattery(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::BatteryState* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getBattery(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::BatteryState* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setGps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::GpsState, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::GpsState* request, ::google::protobuf::Empty* response) { return this->setGps(context, request, response); }));}
    void SetMessageAllocatorFor_setGps(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::GpsState, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::GpsState, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGps(::grpc::ServerContext* /*context*/, const ::android::emulation::control::GpsState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setGps(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::GpsState* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setGps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::GpsState* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getGps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::GpsState>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::android::emulation::control::GpsState* response) { return this->getGps(context, request, response); }));}
    void SetMessageAllocatorFor_getGps(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::android::emulation::control::GpsState>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::GpsState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::GpsState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getGps(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::GpsState* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getGps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::GpsState* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendFingerprint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendFingerprint() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::Fingerprint, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::Fingerprint* request, ::google::protobuf::Empty* response) { return this->sendFingerprint(context, request, response); }));}
    void SetMessageAllocatorFor_sendFingerprint(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::Fingerprint, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::Fingerprint, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendFingerprint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFingerprint(::grpc::ServerContext* /*context*/, const ::android::emulation::control::Fingerprint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendFingerprint(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::Fingerprint* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendFingerprint(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::Fingerprint* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendKey() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::KeyboardEvent, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::KeyboardEvent* request, ::google::protobuf::Empty* response) { return this->sendKey(context, request, response); }));}
    void SetMessageAllocatorFor_sendKey(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::KeyboardEvent, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::KeyboardEvent, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendKey(::grpc::ServerContext* /*context*/, const ::android::emulation::control::KeyboardEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendKey(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::KeyboardEvent* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendKey(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::KeyboardEvent* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendTouch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::TouchEvent, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::TouchEvent* request, ::google::protobuf::Empty* response) { return this->sendTouch(context, request, response); }));}
    void SetMessageAllocatorFor_sendTouch(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::TouchEvent, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::TouchEvent, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTouch(::grpc::ServerContext* /*context*/, const ::android::emulation::control::TouchEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendTouch(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::TouchEvent* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendTouch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::TouchEvent* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendMouse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendMouse() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::MouseEvent, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::MouseEvent* request, ::google::protobuf::Empty* response) { return this->sendMouse(context, request, response); }));}
    void SetMessageAllocatorFor_sendMouse(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::MouseEvent, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::MouseEvent, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendMouse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendMouse(::grpc::ServerContext* /*context*/, const ::android::emulation::control::MouseEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendMouse(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::MouseEvent* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendMouse(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::MouseEvent* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendPhone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendPhone() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::PhoneCall, ::android::emulation::control::PhoneResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::PhoneCall* request, ::android::emulation::control::PhoneResponse* response) { return this->sendPhone(context, request, response); }));}
    void SetMessageAllocatorFor_sendPhone(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::PhoneCall, ::android::emulation::control::PhoneResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::PhoneCall, ::android::emulation::control::PhoneResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendPhone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendPhone(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhoneCall* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendPhone(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::PhoneCall* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendPhone(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::PhoneCall* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_sendSms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_sendSms() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::SmsMessage, ::android::emulation::control::PhoneResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::SmsMessage* request, ::android::emulation::control::PhoneResponse* response) { return this->sendSms(context, request, response); }));}
    void SetMessageAllocatorFor_sendSms(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::SmsMessage, ::android::emulation::control::PhoneResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::SmsMessage, ::android::emulation::control::PhoneResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_sendSms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendSms(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SmsMessage* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendSms(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::SmsMessage* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendSms(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::SmsMessage* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::EmulatorStatus>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::android::emulation::control::EmulatorStatus* response) { return this->getStatus(context, request, response); }));}
    void SetMessageAllocatorFor_getStatus(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::android::emulation::control::EmulatorStatus>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::EmulatorStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::EmulatorStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::EmulatorStatus* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::EmulatorStatus* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getScreenshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::ImageFormat, ::android::emulation::control::Image>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::ImageFormat* request, ::android::emulation::control::Image* response) { return this->getScreenshot(context, request, response); }));}
    void SetMessageAllocatorFor_getScreenshot(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::ImageFormat, ::android::emulation::control::Image>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::ImageFormat, ::android::emulation::control::Image>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::android::emulation::control::Image* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getScreenshot(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::android::emulation::control::Image* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getScreenshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::android::emulation::control::Image* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_streamScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_streamScreenshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::android::emulation::control::ImageFormat, ::android::emulation::control::Image>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::ImageFormat* request) { return this->streamScreenshot(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_streamScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::android::emulation::control::Image>* streamScreenshot(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::android::emulation::control::Image>* streamScreenshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_streamAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_streamAudio() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::android::emulation::control::AudioFormat, ::android::emulation::control::AudioPacket>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::AudioFormat* request) { return this->streamAudio(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_streamAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAudio(::grpc::ServerContext* /*context*/, const ::android::emulation::control::AudioFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::AudioPacket>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::android::emulation::control::AudioPacket>* streamAudio(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::AudioFormat* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::android::emulation::control::AudioPacket>* streamAudio(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::AudioFormat* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getLogcat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::LogMessage, ::android::emulation::control::LogMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::LogMessage* request, ::android::emulation::control::LogMessage* response) { return this->getLogcat(context, request, response); }));}
    void SetMessageAllocatorFor_getLogcat(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::LogMessage, ::android::emulation::control::LogMessage>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::LogMessage, ::android::emulation::control::LogMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::android::emulation::control::LogMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getLogcat(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::android::emulation::control::LogMessage* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getLogcat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::android::emulation::control::LogMessage* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_streamLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_streamLogcat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::android::emulation::control::LogMessage, ::android::emulation::control::LogMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::LogMessage* request) { return this->streamLogcat(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_streamLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::LogMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::android::emulation::control::LogMessage>* streamLogcat(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::android::emulation::control::LogMessage>* streamLogcat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setVmState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::VmRunState, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::android::emulation::control::VmRunState* request, ::google::protobuf::Empty* response) { return this->setVmState(context, request, response); }));}
    void SetMessageAllocatorFor_setVmState(
        ::grpc::experimental::MessageAllocator< ::android::emulation::control::VmRunState, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::android::emulation::control::VmRunState, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setVmState(::grpc::ServerContext* /*context*/, const ::android::emulation::control::VmRunState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setVmState(
      ::grpc::CallbackServerContext* /*context*/, const ::android::emulation::control::VmRunState* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setVmState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::android::emulation::control::VmRunState* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getVmState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::VmRunState>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::android::emulation::control::VmRunState* response) { return this->getVmState(context, request, response); }));}
    void SetMessageAllocatorFor_getVmState(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::android::emulation::control::VmRunState>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::android::emulation::control::VmRunState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVmState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::VmRunState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getVmState(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::VmRunState* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getVmState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::VmRunState* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_streamSensor<ExperimentalWithCallbackMethod_getSensor<ExperimentalWithCallbackMethod_setSensor<ExperimentalWithCallbackMethod_setPhysicalModel<ExperimentalWithCallbackMethod_getPhysicalModel<ExperimentalWithCallbackMethod_streamPhysicalModel<ExperimentalWithCallbackMethod_setClipboard<ExperimentalWithCallbackMethod_getClipboard<ExperimentalWithCallbackMethod_streamClipboard<ExperimentalWithCallbackMethod_setBattery<ExperimentalWithCallbackMethod_getBattery<ExperimentalWithCallbackMethod_setGps<ExperimentalWithCallbackMethod_getGps<ExperimentalWithCallbackMethod_sendFingerprint<ExperimentalWithCallbackMethod_sendKey<ExperimentalWithCallbackMethod_sendTouch<ExperimentalWithCallbackMethod_sendMouse<ExperimentalWithCallbackMethod_sendPhone<ExperimentalWithCallbackMethod_sendSms<ExperimentalWithCallbackMethod_getStatus<ExperimentalWithCallbackMethod_getScreenshot<ExperimentalWithCallbackMethod_streamScreenshot<ExperimentalWithCallbackMethod_streamAudio<ExperimentalWithCallbackMethod_getLogcat<ExperimentalWithCallbackMethod_streamLogcat<ExperimentalWithCallbackMethod_setVmState<ExperimentalWithCallbackMethod_getVmState<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_streamSensor<ExperimentalWithCallbackMethod_getSensor<ExperimentalWithCallbackMethod_setSensor<ExperimentalWithCallbackMethod_setPhysicalModel<ExperimentalWithCallbackMethod_getPhysicalModel<ExperimentalWithCallbackMethod_streamPhysicalModel<ExperimentalWithCallbackMethod_setClipboard<ExperimentalWithCallbackMethod_getClipboard<ExperimentalWithCallbackMethod_streamClipboard<ExperimentalWithCallbackMethod_setBattery<ExperimentalWithCallbackMethod_getBattery<ExperimentalWithCallbackMethod_setGps<ExperimentalWithCallbackMethod_getGps<ExperimentalWithCallbackMethod_sendFingerprint<ExperimentalWithCallbackMethod_sendKey<ExperimentalWithCallbackMethod_sendTouch<ExperimentalWithCallbackMethod_sendMouse<ExperimentalWithCallbackMethod_sendPhone<ExperimentalWithCallbackMethod_sendSms<ExperimentalWithCallbackMethod_getStatus<ExperimentalWithCallbackMethod_getScreenshot<ExperimentalWithCallbackMethod_streamScreenshot<ExperimentalWithCallbackMethod_streamAudio<ExperimentalWithCallbackMethod_getLogcat<ExperimentalWithCallbackMethod_streamLogcat<ExperimentalWithCallbackMethod_setVmState<ExperimentalWithCallbackMethod_getVmState<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_streamSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_streamSensor() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_streamSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::SensorValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getSensor() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_getSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::android::emulation::control::SensorValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setSensor() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_setSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setPhysicalModel() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_setPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getPhysicalModel() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_getPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::android::emulation::control::PhysicalModelValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_streamPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_streamPhysicalModel() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_streamPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::PhysicalModelValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setClipboard() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_setClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClipboard(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ClipData* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getClipboard() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_getClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::ClipData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_streamClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_streamClipboard() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_streamClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::ClipData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setBattery() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_setBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setBattery(::grpc::ServerContext* /*context*/, const ::android::emulation::control::BatteryState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getBattery() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_getBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getBattery(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::BatteryState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setGps() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_setGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGps(::grpc::ServerContext* /*context*/, const ::android::emulation::control::GpsState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getGps() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_getGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::GpsState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sendFingerprint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendFingerprint() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_sendFingerprint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFingerprint(::grpc::ServerContext* /*context*/, const ::android::emulation::control::Fingerprint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sendKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendKey() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_sendKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendKey(::grpc::ServerContext* /*context*/, const ::android::emulation::control::KeyboardEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sendTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendTouch() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_sendTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTouch(::grpc::ServerContext* /*context*/, const ::android::emulation::control::TouchEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sendMouse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendMouse() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_sendMouse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendMouse(::grpc::ServerContext* /*context*/, const ::android::emulation::control::MouseEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sendPhone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendPhone() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_sendPhone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendPhone(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhoneCall* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sendSms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sendSms() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_sendSms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendSms(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SmsMessage* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getStatus() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::EmulatorStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getScreenshot() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_getScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::android::emulation::control::Image* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_streamScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_streamScreenshot() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_streamScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_streamAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_streamAudio() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_streamAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAudio(::grpc::ServerContext* /*context*/, const ::android::emulation::control::AudioFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::AudioPacket>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getLogcat() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_getLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::android::emulation::control::LogMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_streamLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_streamLogcat() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_streamLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::LogMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setVmState() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_setVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setVmState(::grpc::ServerContext* /*context*/, const ::android::emulation::control::VmRunState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getVmState() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_getVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVmState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::VmRunState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_streamSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_streamSensor() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_streamSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::SensorValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamSensor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getSensor() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_getSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::android::emulation::control::SensorValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSensor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setSensor() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_setSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetSensor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setPhysicalModel() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_setPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetPhysicalModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getPhysicalModel() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_getPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::android::emulation::control::PhysicalModelValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetPhysicalModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_streamPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_streamPhysicalModel() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_streamPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::PhysicalModelValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamPhysicalModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setClipboard() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_setClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClipboard(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ClipData* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetClipboard(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getClipboard() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_getClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::ClipData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetClipboard(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_streamClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_streamClipboard() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_streamClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::ClipData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamClipboard(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setBattery() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_setBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setBattery(::grpc::ServerContext* /*context*/, const ::android::emulation::control::BatteryState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetBattery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getBattery() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_getBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getBattery(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::BatteryState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetBattery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setGps() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_setGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGps(::grpc::ServerContext* /*context*/, const ::android::emulation::control::GpsState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetGps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getGps() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_getGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::GpsState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetGps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendFingerprint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendFingerprint() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_sendFingerprint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFingerprint(::grpc::ServerContext* /*context*/, const ::android::emulation::control::Fingerprint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendFingerprint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendKey() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_sendKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendKey(::grpc::ServerContext* /*context*/, const ::android::emulation::control::KeyboardEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendKey(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendTouch() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_sendTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTouch(::grpc::ServerContext* /*context*/, const ::android::emulation::control::TouchEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendTouch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendMouse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendMouse() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_sendMouse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendMouse(::grpc::ServerContext* /*context*/, const ::android::emulation::control::MouseEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendMouse(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendPhone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendPhone() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_sendPhone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendPhone(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhoneCall* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendPhone(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sendSms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sendSms() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_sendSms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendSms(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SmsMessage* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsendSms(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getStatus() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::EmulatorStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getScreenshot() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_getScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::android::emulation::control::Image* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetScreenshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_streamScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_streamScreenshot() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_streamScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamScreenshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(21, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_streamAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_streamAudio() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_streamAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAudio(::grpc::ServerContext* /*context*/, const ::android::emulation::control::AudioFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::AudioPacket>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamAudio(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getLogcat() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_getLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::android::emulation::control::LogMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLogcat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_streamLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_streamLogcat() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_streamLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::LogMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequeststreamLogcat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(24, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setVmState() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_setVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setVmState(::grpc::ServerContext* /*context*/, const ::android::emulation::control::VmRunState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetVmState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getVmState() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_getVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVmState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::VmRunState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetVmState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_streamSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_streamSensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->streamSensor(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_streamSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::SensorValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* streamSensor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* streamSensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getSensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getSensor(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::android::emulation::control::SensorValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getSensor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getSensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setSensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setSensor(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setSensor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setSensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setPhysicalModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setPhysicalModel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setPhysicalModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setPhysicalModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getPhysicalModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getPhysicalModel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::android::emulation::control::PhysicalModelValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getPhysicalModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getPhysicalModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_streamPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_streamPhysicalModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->streamPhysicalModel(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_streamPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::PhysicalModelValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* streamPhysicalModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* streamPhysicalModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setClipboard() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setClipboard(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setClipboard(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ClipData* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setClipboard(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setClipboard(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getClipboard() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getClipboard(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::ClipData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getClipboard(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getClipboard(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_streamClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_streamClipboard() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->streamClipboard(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_streamClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::ClipData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* streamClipboard(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* streamClipboard(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setBattery() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setBattery(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setBattery(::grpc::ServerContext* /*context*/, const ::android::emulation::control::BatteryState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setBattery(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setBattery(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getBattery() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getBattery(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getBattery(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::BatteryState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getBattery(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getBattery(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setGps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setGps(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setGps(::grpc::ServerContext* /*context*/, const ::android::emulation::control::GpsState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setGps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setGps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getGps() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getGps(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getGps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::GpsState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getGps(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getGps(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendFingerprint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendFingerprint() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendFingerprint(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendFingerprint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendFingerprint(::grpc::ServerContext* /*context*/, const ::android::emulation::control::Fingerprint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendFingerprint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendFingerprint(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendKey() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendKey(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendKey(::grpc::ServerContext* /*context*/, const ::android::emulation::control::KeyboardEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendKey(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendKey(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendTouch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendTouch(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendTouch(::grpc::ServerContext* /*context*/, const ::android::emulation::control::TouchEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendTouch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendTouch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendMouse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendMouse() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendMouse(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendMouse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendMouse(::grpc::ServerContext* /*context*/, const ::android::emulation::control::MouseEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendMouse(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendMouse(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendPhone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendPhone() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendPhone(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendPhone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendPhone(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhoneCall* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendPhone(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendPhone(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_sendSms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_sendSms() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sendSms(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_sendSms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sendSms(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SmsMessage* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* sendSms(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* sendSms(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::EmulatorStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getScreenshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getScreenshot(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::android::emulation::control::Image* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getScreenshot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getScreenshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_streamScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_streamScreenshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->streamScreenshot(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_streamScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* streamScreenshot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* streamScreenshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_streamAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_streamAudio() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->streamAudio(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_streamAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamAudio(::grpc::ServerContext* /*context*/, const ::android::emulation::control::AudioFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::AudioPacket>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* streamAudio(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* streamAudio(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getLogcat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getLogcat(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::android::emulation::control::LogMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getLogcat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getLogcat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_streamLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_streamLogcat() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->streamLogcat(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_streamLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status streamLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::LogMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* streamLogcat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* streamLogcat(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setVmState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setVmState(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setVmState(::grpc::ServerContext* /*context*/, const ::android::emulation::control::VmRunState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setVmState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setVmState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getVmState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getVmState(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVmState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::VmRunState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getVmState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getVmState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getSensor() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::SensorValue, ::android::emulation::control::SensorValue>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::SensorValue, ::android::emulation::control::SensorValue>* streamer) {
                       return this->StreamedgetSensor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::android::emulation::control::SensorValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetSensor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::SensorValue,::android::emulation::control::SensorValue>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setSensor() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::SensorValue, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::SensorValue, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetSensor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetSensor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::SensorValue,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setPhysicalModel() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::PhysicalModelValue, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::PhysicalModelValue, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetPhysicalModel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetPhysicalModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::PhysicalModelValue,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getPhysicalModel() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::PhysicalModelValue, ::android::emulation::control::PhysicalModelValue>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::PhysicalModelValue, ::android::emulation::control::PhysicalModelValue>* streamer) {
                       return this->StreamedgetPhysicalModel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::android::emulation::control::PhysicalModelValue* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetPhysicalModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::PhysicalModelValue,::android::emulation::control::PhysicalModelValue>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setClipboard() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::ClipData, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::ClipData, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetClipboard(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setClipboard(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ClipData* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetClipboard(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::ClipData,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getClipboard() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::android::emulation::control::ClipData>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::android::emulation::control::ClipData>* streamer) {
                       return this->StreamedgetClipboard(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::ClipData* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetClipboard(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::android::emulation::control::ClipData>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setBattery() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::BatteryState, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::BatteryState, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetBattery(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setBattery(::grpc::ServerContext* /*context*/, const ::android::emulation::control::BatteryState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetBattery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::BatteryState,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getBattery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getBattery() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::android::emulation::control::BatteryState>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::android::emulation::control::BatteryState>* streamer) {
                       return this->StreamedgetBattery(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getBattery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getBattery(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::BatteryState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetBattery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::android::emulation::control::BatteryState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setGps() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::GpsState, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::GpsState, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetGps(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setGps(::grpc::ServerContext* /*context*/, const ::android::emulation::control::GpsState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetGps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::GpsState,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getGps : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getGps() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::android::emulation::control::GpsState>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::android::emulation::control::GpsState>* streamer) {
                       return this->StreamedgetGps(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getGps() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getGps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::GpsState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetGps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::android::emulation::control::GpsState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendFingerprint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendFingerprint() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::Fingerprint, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::Fingerprint, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsendFingerprint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendFingerprint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendFingerprint(::grpc::ServerContext* /*context*/, const ::android::emulation::control::Fingerprint* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendFingerprint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::Fingerprint,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendKey() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::KeyboardEvent, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::KeyboardEvent, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsendKey(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendKey(::grpc::ServerContext* /*context*/, const ::android::emulation::control::KeyboardEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendKey(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::KeyboardEvent,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendTouch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendTouch() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::TouchEvent, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::TouchEvent, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsendTouch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendTouch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendTouch(::grpc::ServerContext* /*context*/, const ::android::emulation::control::TouchEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendTouch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::TouchEvent,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendMouse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendMouse() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::MouseEvent, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::MouseEvent, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsendMouse(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendMouse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendMouse(::grpc::ServerContext* /*context*/, const ::android::emulation::control::MouseEvent* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendMouse(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::MouseEvent,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendPhone : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendPhone() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::PhoneCall, ::android::emulation::control::PhoneResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::PhoneCall, ::android::emulation::control::PhoneResponse>* streamer) {
                       return this->StreamedsendPhone(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendPhone() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendPhone(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhoneCall* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendPhone(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::PhoneCall,::android::emulation::control::PhoneResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sendSms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sendSms() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::SmsMessage, ::android::emulation::control::PhoneResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::SmsMessage, ::android::emulation::control::PhoneResponse>* streamer) {
                       return this->StreamedsendSms(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sendSms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sendSms(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SmsMessage* /*request*/, ::android::emulation::control::PhoneResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsendSms(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::SmsMessage,::android::emulation::control::PhoneResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getStatus() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::android::emulation::control::EmulatorStatus>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::android::emulation::control::EmulatorStatus>* streamer) {
                       return this->StreamedgetStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::EmulatorStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::android::emulation::control::EmulatorStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getScreenshot() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::ImageFormat, ::android::emulation::control::Image>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::ImageFormat, ::android::emulation::control::Image>* streamer) {
                       return this->StreamedgetScreenshot(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::android::emulation::control::Image* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetScreenshot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::ImageFormat,::android::emulation::control::Image>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getLogcat() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::LogMessage, ::android::emulation::control::LogMessage>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::LogMessage, ::android::emulation::control::LogMessage>* streamer) {
                       return this->StreamedgetLogcat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::android::emulation::control::LogMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetLogcat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::LogMessage,::android::emulation::control::LogMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setVmState() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::android::emulation::control::VmRunState, ::google::protobuf::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::android::emulation::control::VmRunState, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetVmState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setVmState(::grpc::ServerContext* /*context*/, const ::android::emulation::control::VmRunState* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetVmState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::android::emulation::control::VmRunState,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getVmState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getVmState() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::android::emulation::control::VmRunState>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::android::emulation::control::VmRunState>* streamer) {
                       return this->StreamedgetVmState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getVmState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getVmState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::android::emulation::control::VmRunState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetVmState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::android::emulation::control::VmRunState>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_getSensor<WithStreamedUnaryMethod_setSensor<WithStreamedUnaryMethod_setPhysicalModel<WithStreamedUnaryMethod_getPhysicalModel<WithStreamedUnaryMethod_setClipboard<WithStreamedUnaryMethod_getClipboard<WithStreamedUnaryMethod_setBattery<WithStreamedUnaryMethod_getBattery<WithStreamedUnaryMethod_setGps<WithStreamedUnaryMethod_getGps<WithStreamedUnaryMethod_sendFingerprint<WithStreamedUnaryMethod_sendKey<WithStreamedUnaryMethod_sendTouch<WithStreamedUnaryMethod_sendMouse<WithStreamedUnaryMethod_sendPhone<WithStreamedUnaryMethod_sendSms<WithStreamedUnaryMethod_getStatus<WithStreamedUnaryMethod_getScreenshot<WithStreamedUnaryMethod_getLogcat<WithStreamedUnaryMethod_setVmState<WithStreamedUnaryMethod_getVmState<Service > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_streamSensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_streamSensor() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::android::emulation::control::SensorValue, ::android::emulation::control::SensorValue>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::android::emulation::control::SensorValue, ::android::emulation::control::SensorValue>* streamer) {
                       return this->StreamedstreamSensor(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_streamSensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status streamSensor(::grpc::ServerContext* /*context*/, const ::android::emulation::control::SensorValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::SensorValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedstreamSensor(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::android::emulation::control::SensorValue,::android::emulation::control::SensorValue>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_streamPhysicalModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_streamPhysicalModel() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::android::emulation::control::PhysicalModelValue, ::android::emulation::control::PhysicalModelValue>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::android::emulation::control::PhysicalModelValue, ::android::emulation::control::PhysicalModelValue>* streamer) {
                       return this->StreamedstreamPhysicalModel(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_streamPhysicalModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status streamPhysicalModel(::grpc::ServerContext* /*context*/, const ::android::emulation::control::PhysicalModelValue* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::PhysicalModelValue>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedstreamPhysicalModel(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::android::emulation::control::PhysicalModelValue,::android::emulation::control::PhysicalModelValue>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_streamClipboard : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_streamClipboard() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::google::protobuf::Empty, ::android::emulation::control::ClipData>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::google::protobuf::Empty, ::android::emulation::control::ClipData>* streamer) {
                       return this->StreamedstreamClipboard(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_streamClipboard() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status streamClipboard(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::ClipData>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedstreamClipboard(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::google::protobuf::Empty,::android::emulation::control::ClipData>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_streamScreenshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_streamScreenshot() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::android::emulation::control::ImageFormat, ::android::emulation::control::Image>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::android::emulation::control::ImageFormat, ::android::emulation::control::Image>* streamer) {
                       return this->StreamedstreamScreenshot(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_streamScreenshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status streamScreenshot(::grpc::ServerContext* /*context*/, const ::android::emulation::control::ImageFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedstreamScreenshot(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::android::emulation::control::ImageFormat,::android::emulation::control::Image>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_streamAudio : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_streamAudio() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::android::emulation::control::AudioFormat, ::android::emulation::control::AudioPacket>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::android::emulation::control::AudioFormat, ::android::emulation::control::AudioPacket>* streamer) {
                       return this->StreamedstreamAudio(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_streamAudio() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status streamAudio(::grpc::ServerContext* /*context*/, const ::android::emulation::control::AudioFormat* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::AudioPacket>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedstreamAudio(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::android::emulation::control::AudioFormat,::android::emulation::control::AudioPacket>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_streamLogcat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_streamLogcat() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::android::emulation::control::LogMessage, ::android::emulation::control::LogMessage>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::android::emulation::control::LogMessage, ::android::emulation::control::LogMessage>* streamer) {
                       return this->StreamedstreamLogcat(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_streamLogcat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status streamLogcat(::grpc::ServerContext* /*context*/, const ::android::emulation::control::LogMessage* /*request*/, ::grpc::ServerWriter< ::android::emulation::control::LogMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedstreamLogcat(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::android::emulation::control::LogMessage,::android::emulation::control::LogMessage>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_streamSensor<WithSplitStreamingMethod_streamPhysicalModel<WithSplitStreamingMethod_streamClipboard<WithSplitStreamingMethod_streamScreenshot<WithSplitStreamingMethod_streamAudio<WithSplitStreamingMethod_streamLogcat<Service > > > > > > SplitStreamedService;
  typedef WithSplitStreamingMethod_streamSensor<WithStreamedUnaryMethod_getSensor<WithStreamedUnaryMethod_setSensor<WithStreamedUnaryMethod_setPhysicalModel<WithStreamedUnaryMethod_getPhysicalModel<WithSplitStreamingMethod_streamPhysicalModel<WithStreamedUnaryMethod_setClipboard<WithStreamedUnaryMethod_getClipboard<WithSplitStreamingMethod_streamClipboard<WithStreamedUnaryMethod_setBattery<WithStreamedUnaryMethod_getBattery<WithStreamedUnaryMethod_setGps<WithStreamedUnaryMethod_getGps<WithStreamedUnaryMethod_sendFingerprint<WithStreamedUnaryMethod_sendKey<WithStreamedUnaryMethod_sendTouch<WithStreamedUnaryMethod_sendMouse<WithStreamedUnaryMethod_sendPhone<WithStreamedUnaryMethod_sendSms<WithStreamedUnaryMethod_getStatus<WithStreamedUnaryMethod_getScreenshot<WithSplitStreamingMethod_streamScreenshot<WithSplitStreamingMethod_streamAudio<WithStreamedUnaryMethod_getLogcat<WithSplitStreamingMethod_streamLogcat<WithStreamedUnaryMethod_setVmState<WithStreamedUnaryMethod_getVmState<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace control
}  // namespace emulation
}  // namespace android


#endif  // GRPC_emulator_5fcontroller_2eproto__INCLUDED
