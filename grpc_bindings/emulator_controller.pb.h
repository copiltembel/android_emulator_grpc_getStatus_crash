// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: emulator_controller.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_emulator_5fcontroller_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_emulator_5fcontroller_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_emulator_5fcontroller_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_emulator_5fcontroller_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_emulator_5fcontroller_2eproto;
namespace android {
namespace emulation {
namespace control {
class AudioFormat;
class AudioFormatDefaultTypeInternal;
extern AudioFormatDefaultTypeInternal _AudioFormat_default_instance_;
class AudioPacket;
class AudioPacketDefaultTypeInternal;
extern AudioPacketDefaultTypeInternal _AudioPacket_default_instance_;
class BatteryState;
class BatteryStateDefaultTypeInternal;
extern BatteryStateDefaultTypeInternal _BatteryState_default_instance_;
class ClipData;
class ClipDataDefaultTypeInternal;
extern ClipDataDefaultTypeInternal _ClipData_default_instance_;
class EmulatorStatus;
class EmulatorStatusDefaultTypeInternal;
extern EmulatorStatusDefaultTypeInternal _EmulatorStatus_default_instance_;
class Entry;
class EntryDefaultTypeInternal;
extern EntryDefaultTypeInternal _Entry_default_instance_;
class EntryList;
class EntryListDefaultTypeInternal;
extern EntryListDefaultTypeInternal _EntryList_default_instance_;
class Fingerprint;
class FingerprintDefaultTypeInternal;
extern FingerprintDefaultTypeInternal _Fingerprint_default_instance_;
class GpsState;
class GpsStateDefaultTypeInternal;
extern GpsStateDefaultTypeInternal _GpsState_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImageFormat;
class ImageFormatDefaultTypeInternal;
extern ImageFormatDefaultTypeInternal _ImageFormat_default_instance_;
class ImageTransport;
class ImageTransportDefaultTypeInternal;
extern ImageTransportDefaultTypeInternal _ImageTransport_default_instance_;
class KeyboardEvent;
class KeyboardEventDefaultTypeInternal;
extern KeyboardEventDefaultTypeInternal _KeyboardEvent_default_instance_;
class LogMessage;
class LogMessageDefaultTypeInternal;
extern LogMessageDefaultTypeInternal _LogMessage_default_instance_;
class LogcatEntry;
class LogcatEntryDefaultTypeInternal;
extern LogcatEntryDefaultTypeInternal _LogcatEntry_default_instance_;
class MouseEvent;
class MouseEventDefaultTypeInternal;
extern MouseEventDefaultTypeInternal _MouseEvent_default_instance_;
class ParameterValue;
class ParameterValueDefaultTypeInternal;
extern ParameterValueDefaultTypeInternal _ParameterValue_default_instance_;
class PhoneCall;
class PhoneCallDefaultTypeInternal;
extern PhoneCallDefaultTypeInternal _PhoneCall_default_instance_;
class PhoneResponse;
class PhoneResponseDefaultTypeInternal;
extern PhoneResponseDefaultTypeInternal _PhoneResponse_default_instance_;
class PhysicalModelValue;
class PhysicalModelValueDefaultTypeInternal;
extern PhysicalModelValueDefaultTypeInternal _PhysicalModelValue_default_instance_;
class Rotation;
class RotationDefaultTypeInternal;
extern RotationDefaultTypeInternal _Rotation_default_instance_;
class SensorValue;
class SensorValueDefaultTypeInternal;
extern SensorValueDefaultTypeInternal _SensorValue_default_instance_;
class SmsMessage;
class SmsMessageDefaultTypeInternal;
extern SmsMessageDefaultTypeInternal _SmsMessage_default_instance_;
class Touch;
class TouchDefaultTypeInternal;
extern TouchDefaultTypeInternal _Touch_default_instance_;
class TouchEvent;
class TouchEventDefaultTypeInternal;
extern TouchEventDefaultTypeInternal _TouchEvent_default_instance_;
class VmConfiguration;
class VmConfigurationDefaultTypeInternal;
extern VmConfigurationDefaultTypeInternal _VmConfiguration_default_instance_;
class VmRunState;
class VmRunStateDefaultTypeInternal;
extern VmRunStateDefaultTypeInternal _VmRunState_default_instance_;
}  // namespace control
}  // namespace emulation
}  // namespace android
PROTOBUF_NAMESPACE_OPEN
template<> ::android::emulation::control::AudioFormat* Arena::CreateMaybeMessage<::android::emulation::control::AudioFormat>(Arena*);
template<> ::android::emulation::control::AudioPacket* Arena::CreateMaybeMessage<::android::emulation::control::AudioPacket>(Arena*);
template<> ::android::emulation::control::BatteryState* Arena::CreateMaybeMessage<::android::emulation::control::BatteryState>(Arena*);
template<> ::android::emulation::control::ClipData* Arena::CreateMaybeMessage<::android::emulation::control::ClipData>(Arena*);
template<> ::android::emulation::control::EmulatorStatus* Arena::CreateMaybeMessage<::android::emulation::control::EmulatorStatus>(Arena*);
template<> ::android::emulation::control::Entry* Arena::CreateMaybeMessage<::android::emulation::control::Entry>(Arena*);
template<> ::android::emulation::control::EntryList* Arena::CreateMaybeMessage<::android::emulation::control::EntryList>(Arena*);
template<> ::android::emulation::control::Fingerprint* Arena::CreateMaybeMessage<::android::emulation::control::Fingerprint>(Arena*);
template<> ::android::emulation::control::GpsState* Arena::CreateMaybeMessage<::android::emulation::control::GpsState>(Arena*);
template<> ::android::emulation::control::Image* Arena::CreateMaybeMessage<::android::emulation::control::Image>(Arena*);
template<> ::android::emulation::control::ImageFormat* Arena::CreateMaybeMessage<::android::emulation::control::ImageFormat>(Arena*);
template<> ::android::emulation::control::ImageTransport* Arena::CreateMaybeMessage<::android::emulation::control::ImageTransport>(Arena*);
template<> ::android::emulation::control::KeyboardEvent* Arena::CreateMaybeMessage<::android::emulation::control::KeyboardEvent>(Arena*);
template<> ::android::emulation::control::LogMessage* Arena::CreateMaybeMessage<::android::emulation::control::LogMessage>(Arena*);
template<> ::android::emulation::control::LogcatEntry* Arena::CreateMaybeMessage<::android::emulation::control::LogcatEntry>(Arena*);
template<> ::android::emulation::control::MouseEvent* Arena::CreateMaybeMessage<::android::emulation::control::MouseEvent>(Arena*);
template<> ::android::emulation::control::ParameterValue* Arena::CreateMaybeMessage<::android::emulation::control::ParameterValue>(Arena*);
template<> ::android::emulation::control::PhoneCall* Arena::CreateMaybeMessage<::android::emulation::control::PhoneCall>(Arena*);
template<> ::android::emulation::control::PhoneResponse* Arena::CreateMaybeMessage<::android::emulation::control::PhoneResponse>(Arena*);
template<> ::android::emulation::control::PhysicalModelValue* Arena::CreateMaybeMessage<::android::emulation::control::PhysicalModelValue>(Arena*);
template<> ::android::emulation::control::Rotation* Arena::CreateMaybeMessage<::android::emulation::control::Rotation>(Arena*);
template<> ::android::emulation::control::SensorValue* Arena::CreateMaybeMessage<::android::emulation::control::SensorValue>(Arena*);
template<> ::android::emulation::control::SmsMessage* Arena::CreateMaybeMessage<::android::emulation::control::SmsMessage>(Arena*);
template<> ::android::emulation::control::Touch* Arena::CreateMaybeMessage<::android::emulation::control::Touch>(Arena*);
template<> ::android::emulation::control::TouchEvent* Arena::CreateMaybeMessage<::android::emulation::control::TouchEvent>(Arena*);
template<> ::android::emulation::control::VmConfiguration* Arena::CreateMaybeMessage<::android::emulation::control::VmConfiguration>(Arena*);
template<> ::android::emulation::control::VmRunState* Arena::CreateMaybeMessage<::android::emulation::control::VmRunState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace android {
namespace emulation {
namespace control {

enum VmRunState_RunState : int {
  VmRunState_RunState_UNKNOWN = 0,
  VmRunState_RunState_RUNNING = 1,
  VmRunState_RunState_RESTORE_VM = 2,
  VmRunState_RunState_PAUSED = 3,
  VmRunState_RunState_SAVE_VM = 4,
  VmRunState_RunState_SHUTDOWN = 5,
  VmRunState_RunState_TERMINATE = 7,
  VmRunState_RunState_RESET = 9,
  VmRunState_RunState_INTERNAL_ERROR = 10,
  VmRunState_RunState_VmRunState_RunState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VmRunState_RunState_VmRunState_RunState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VmRunState_RunState_IsValid(int value);
constexpr VmRunState_RunState VmRunState_RunState_RunState_MIN = VmRunState_RunState_UNKNOWN;
constexpr VmRunState_RunState VmRunState_RunState_RunState_MAX = VmRunState_RunState_INTERNAL_ERROR;
constexpr int VmRunState_RunState_RunState_ARRAYSIZE = VmRunState_RunState_RunState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VmRunState_RunState_descriptor();
template<typename T>
inline const std::string& VmRunState_RunState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VmRunState_RunState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VmRunState_RunState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VmRunState_RunState_descriptor(), enum_t_value);
}
inline bool VmRunState_RunState_Parse(
    const std::string& name, VmRunState_RunState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VmRunState_RunState>(
    VmRunState_RunState_descriptor(), name, value);
}
enum PhysicalModelValue_State : int {
  PhysicalModelValue_State_OK = 0,
  PhysicalModelValue_State_NO_SERVICE = -3,
  PhysicalModelValue_State_DISABLED = -2,
  PhysicalModelValue_State_UNKNOWN = -1,
  PhysicalModelValue_State_PhysicalModelValue_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PhysicalModelValue_State_PhysicalModelValue_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PhysicalModelValue_State_IsValid(int value);
constexpr PhysicalModelValue_State PhysicalModelValue_State_State_MIN = PhysicalModelValue_State_NO_SERVICE;
constexpr PhysicalModelValue_State PhysicalModelValue_State_State_MAX = PhysicalModelValue_State_OK;
constexpr int PhysicalModelValue_State_State_ARRAYSIZE = PhysicalModelValue_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PhysicalModelValue_State_descriptor();
template<typename T>
inline const std::string& PhysicalModelValue_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PhysicalModelValue_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PhysicalModelValue_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PhysicalModelValue_State_descriptor(), enum_t_value);
}
inline bool PhysicalModelValue_State_Parse(
    const std::string& name, PhysicalModelValue_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhysicalModelValue_State>(
    PhysicalModelValue_State_descriptor(), name, value);
}
enum PhysicalModelValue_PhysicalType : int {
  PhysicalModelValue_PhysicalType_POSITION = 0,
  PhysicalModelValue_PhysicalType_ROTATION = 1,
  PhysicalModelValue_PhysicalType_MAGNETIC_FIELD = 2,
  PhysicalModelValue_PhysicalType_TEMPERATURE = 3,
  PhysicalModelValue_PhysicalType_PROXIMITY = 4,
  PhysicalModelValue_PhysicalType_LIGHT = 5,
  PhysicalModelValue_PhysicalType_PRESSURE = 6,
  PhysicalModelValue_PhysicalType_HUMIDITY = 7,
  PhysicalModelValue_PhysicalType_VELOCITY = 8,
  PhysicalModelValue_PhysicalType_AMBIENT_MOTION = 9,
  PhysicalModelValue_PhysicalType_PhysicalModelValue_PhysicalType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PhysicalModelValue_PhysicalType_PhysicalModelValue_PhysicalType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PhysicalModelValue_PhysicalType_IsValid(int value);
constexpr PhysicalModelValue_PhysicalType PhysicalModelValue_PhysicalType_PhysicalType_MIN = PhysicalModelValue_PhysicalType_POSITION;
constexpr PhysicalModelValue_PhysicalType PhysicalModelValue_PhysicalType_PhysicalType_MAX = PhysicalModelValue_PhysicalType_AMBIENT_MOTION;
constexpr int PhysicalModelValue_PhysicalType_PhysicalType_ARRAYSIZE = PhysicalModelValue_PhysicalType_PhysicalType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PhysicalModelValue_PhysicalType_descriptor();
template<typename T>
inline const std::string& PhysicalModelValue_PhysicalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PhysicalModelValue_PhysicalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PhysicalModelValue_PhysicalType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PhysicalModelValue_PhysicalType_descriptor(), enum_t_value);
}
inline bool PhysicalModelValue_PhysicalType_Parse(
    const std::string& name, PhysicalModelValue_PhysicalType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhysicalModelValue_PhysicalType>(
    PhysicalModelValue_PhysicalType_descriptor(), name, value);
}
enum SensorValue_State : int {
  SensorValue_State_OK = 0,
  SensorValue_State_NO_SERVICE = -3,
  SensorValue_State_DISABLED = -2,
  SensorValue_State_UNKNOWN = -1,
  SensorValue_State_SensorValue_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SensorValue_State_SensorValue_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SensorValue_State_IsValid(int value);
constexpr SensorValue_State SensorValue_State_State_MIN = SensorValue_State_NO_SERVICE;
constexpr SensorValue_State SensorValue_State_State_MAX = SensorValue_State_OK;
constexpr int SensorValue_State_State_ARRAYSIZE = SensorValue_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorValue_State_descriptor();
template<typename T>
inline const std::string& SensorValue_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorValue_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorValue_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorValue_State_descriptor(), enum_t_value);
}
inline bool SensorValue_State_Parse(
    const std::string& name, SensorValue_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorValue_State>(
    SensorValue_State_descriptor(), name, value);
}
enum SensorValue_SensorType : int {
  SensorValue_SensorType_ACCELERATION = 0,
  SensorValue_SensorType_GYROSCOPE = 1,
  SensorValue_SensorType_MAGNETIC_FIELD = 2,
  SensorValue_SensorType_ORIENTATION = 3,
  SensorValue_SensorType_TEMPERATURE = 4,
  SensorValue_SensorType_PROXIMITY = 5,
  SensorValue_SensorType_LIGHT = 6,
  SensorValue_SensorType_PRESSURE = 7,
  SensorValue_SensorType_HUMIDITY = 8,
  SensorValue_SensorType_MAGNETIC_FIELD_UNCALIBRATED = 9,
  SensorValue_SensorType_GYROSCOPE_UNCALIBRATED = 10,
  SensorValue_SensorType_SensorValue_SensorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SensorValue_SensorType_SensorValue_SensorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SensorValue_SensorType_IsValid(int value);
constexpr SensorValue_SensorType SensorValue_SensorType_SensorType_MIN = SensorValue_SensorType_ACCELERATION;
constexpr SensorValue_SensorType SensorValue_SensorType_SensorType_MAX = SensorValue_SensorType_GYROSCOPE_UNCALIBRATED;
constexpr int SensorValue_SensorType_SensorType_ARRAYSIZE = SensorValue_SensorType_SensorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorValue_SensorType_descriptor();
template<typename T>
inline const std::string& SensorValue_SensorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorValue_SensorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorValue_SensorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorValue_SensorType_descriptor(), enum_t_value);
}
inline bool SensorValue_SensorType_Parse(
    const std::string& name, SensorValue_SensorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorValue_SensorType>(
    SensorValue_SensorType_descriptor(), name, value);
}
enum LogMessage_LogType : int {
  LogMessage_LogType_Text = 0,
  LogMessage_LogType_Parsed = 1,
  LogMessage_LogType_LogMessage_LogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogMessage_LogType_LogMessage_LogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogMessage_LogType_IsValid(int value);
constexpr LogMessage_LogType LogMessage_LogType_LogType_MIN = LogMessage_LogType_Text;
constexpr LogMessage_LogType LogMessage_LogType_LogType_MAX = LogMessage_LogType_Parsed;
constexpr int LogMessage_LogType_LogType_ARRAYSIZE = LogMessage_LogType_LogType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogMessage_LogType_descriptor();
template<typename T>
inline const std::string& LogMessage_LogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogMessage_LogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogMessage_LogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogMessage_LogType_descriptor(), enum_t_value);
}
inline bool LogMessage_LogType_Parse(
    const std::string& name, LogMessage_LogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogMessage_LogType>(
    LogMessage_LogType_descriptor(), name, value);
}
enum LogcatEntry_LogLevel : int {
  LogcatEntry_LogLevel_UNKNOWN = 0,
  LogcatEntry_LogLevel_DEFAULT = 1,
  LogcatEntry_LogLevel_VERBOSE = 2,
  LogcatEntry_LogLevel_DEBUG = 3,
  LogcatEntry_LogLevel_INFO = 4,
  LogcatEntry_LogLevel_WARN = 5,
  LogcatEntry_LogLevel_ERR = 6,
  LogcatEntry_LogLevel_FATAL = 7,
  LogcatEntry_LogLevel_SILENT = 8,
  LogcatEntry_LogLevel_LogcatEntry_LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogcatEntry_LogLevel_LogcatEntry_LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogcatEntry_LogLevel_IsValid(int value);
constexpr LogcatEntry_LogLevel LogcatEntry_LogLevel_LogLevel_MIN = LogcatEntry_LogLevel_UNKNOWN;
constexpr LogcatEntry_LogLevel LogcatEntry_LogLevel_LogLevel_MAX = LogcatEntry_LogLevel_SILENT;
constexpr int LogcatEntry_LogLevel_LogLevel_ARRAYSIZE = LogcatEntry_LogLevel_LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogcatEntry_LogLevel_descriptor();
template<typename T>
inline const std::string& LogcatEntry_LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogcatEntry_LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogcatEntry_LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogcatEntry_LogLevel_descriptor(), enum_t_value);
}
inline bool LogcatEntry_LogLevel_Parse(
    const std::string& name, LogcatEntry_LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogcatEntry_LogLevel>(
    LogcatEntry_LogLevel_descriptor(), name, value);
}
enum VmConfiguration_VmHypervisorType : int {
  VmConfiguration_VmHypervisorType_UNKNOWN = 0,
  VmConfiguration_VmHypervisorType_NONE = 1,
  VmConfiguration_VmHypervisorType_KVM = 2,
  VmConfiguration_VmHypervisorType_HAXM = 3,
  VmConfiguration_VmHypervisorType_HVF = 4,
  VmConfiguration_VmHypervisorType_WHPX = 5,
  VmConfiguration_VmHypervisorType_GVM = 6,
  VmConfiguration_VmHypervisorType_VmConfiguration_VmHypervisorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VmConfiguration_VmHypervisorType_VmConfiguration_VmHypervisorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VmConfiguration_VmHypervisorType_IsValid(int value);
constexpr VmConfiguration_VmHypervisorType VmConfiguration_VmHypervisorType_VmHypervisorType_MIN = VmConfiguration_VmHypervisorType_UNKNOWN;
constexpr VmConfiguration_VmHypervisorType VmConfiguration_VmHypervisorType_VmHypervisorType_MAX = VmConfiguration_VmHypervisorType_GVM;
constexpr int VmConfiguration_VmHypervisorType_VmHypervisorType_ARRAYSIZE = VmConfiguration_VmHypervisorType_VmHypervisorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VmConfiguration_VmHypervisorType_descriptor();
template<typename T>
inline const std::string& VmConfiguration_VmHypervisorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VmConfiguration_VmHypervisorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VmConfiguration_VmHypervisorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VmConfiguration_VmHypervisorType_descriptor(), enum_t_value);
}
inline bool VmConfiguration_VmHypervisorType_Parse(
    const std::string& name, VmConfiguration_VmHypervisorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VmConfiguration_VmHypervisorType>(
    VmConfiguration_VmHypervisorType_descriptor(), name, value);
}
enum KeyboardEvent_KeyCodeType : int {
  KeyboardEvent_KeyCodeType_Usb = 0,
  KeyboardEvent_KeyCodeType_Evdev = 1,
  KeyboardEvent_KeyCodeType_XKB = 2,
  KeyboardEvent_KeyCodeType_Win = 3,
  KeyboardEvent_KeyCodeType_Mac = 4,
  KeyboardEvent_KeyCodeType_KeyboardEvent_KeyCodeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KeyboardEvent_KeyCodeType_KeyboardEvent_KeyCodeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KeyboardEvent_KeyCodeType_IsValid(int value);
constexpr KeyboardEvent_KeyCodeType KeyboardEvent_KeyCodeType_KeyCodeType_MIN = KeyboardEvent_KeyCodeType_Usb;
constexpr KeyboardEvent_KeyCodeType KeyboardEvent_KeyCodeType_KeyCodeType_MAX = KeyboardEvent_KeyCodeType_Mac;
constexpr int KeyboardEvent_KeyCodeType_KeyCodeType_ARRAYSIZE = KeyboardEvent_KeyCodeType_KeyCodeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyboardEvent_KeyCodeType_descriptor();
template<typename T>
inline const std::string& KeyboardEvent_KeyCodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyboardEvent_KeyCodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyboardEvent_KeyCodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyboardEvent_KeyCodeType_descriptor(), enum_t_value);
}
inline bool KeyboardEvent_KeyCodeType_Parse(
    const std::string& name, KeyboardEvent_KeyCodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyboardEvent_KeyCodeType>(
    KeyboardEvent_KeyCodeType_descriptor(), name, value);
}
enum KeyboardEvent_KeyEventType : int {
  KeyboardEvent_KeyEventType_keydown = 0,
  KeyboardEvent_KeyEventType_keyup = 1,
  KeyboardEvent_KeyEventType_keypress = 2,
  KeyboardEvent_KeyEventType_KeyboardEvent_KeyEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KeyboardEvent_KeyEventType_KeyboardEvent_KeyEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KeyboardEvent_KeyEventType_IsValid(int value);
constexpr KeyboardEvent_KeyEventType KeyboardEvent_KeyEventType_KeyEventType_MIN = KeyboardEvent_KeyEventType_keydown;
constexpr KeyboardEvent_KeyEventType KeyboardEvent_KeyEventType_KeyEventType_MAX = KeyboardEvent_KeyEventType_keypress;
constexpr int KeyboardEvent_KeyEventType_KeyEventType_ARRAYSIZE = KeyboardEvent_KeyEventType_KeyEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyboardEvent_KeyEventType_descriptor();
template<typename T>
inline const std::string& KeyboardEvent_KeyEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyboardEvent_KeyEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyboardEvent_KeyEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyboardEvent_KeyEventType_descriptor(), enum_t_value);
}
inline bool KeyboardEvent_KeyEventType_Parse(
    const std::string& name, KeyboardEvent_KeyEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyboardEvent_KeyEventType>(
    KeyboardEvent_KeyEventType_descriptor(), name, value);
}
enum BatteryState_BatteryStatus : int {
  BatteryState_BatteryStatus_UNKNOWN = 0,
  BatteryState_BatteryStatus_CHARGING = 1,
  BatteryState_BatteryStatus_DISCHARGING = 2,
  BatteryState_BatteryStatus_NOT_CHARGING = 3,
  BatteryState_BatteryStatus_FULL = 4,
  BatteryState_BatteryStatus_BatteryState_BatteryStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BatteryState_BatteryStatus_BatteryState_BatteryStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BatteryState_BatteryStatus_IsValid(int value);
constexpr BatteryState_BatteryStatus BatteryState_BatteryStatus_BatteryStatus_MIN = BatteryState_BatteryStatus_UNKNOWN;
constexpr BatteryState_BatteryStatus BatteryState_BatteryStatus_BatteryStatus_MAX = BatteryState_BatteryStatus_FULL;
constexpr int BatteryState_BatteryStatus_BatteryStatus_ARRAYSIZE = BatteryState_BatteryStatus_BatteryStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatteryState_BatteryStatus_descriptor();
template<typename T>
inline const std::string& BatteryState_BatteryStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryState_BatteryStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryState_BatteryStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatteryState_BatteryStatus_descriptor(), enum_t_value);
}
inline bool BatteryState_BatteryStatus_Parse(
    const std::string& name, BatteryState_BatteryStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatteryState_BatteryStatus>(
    BatteryState_BatteryStatus_descriptor(), name, value);
}
enum BatteryState_BatteryCharger : int {
  BatteryState_BatteryCharger_NONE = 0,
  BatteryState_BatteryCharger_AC = 1,
  BatteryState_BatteryCharger_USB = 2,
  BatteryState_BatteryCharger_WIRELESS = 3,
  BatteryState_BatteryCharger_BatteryState_BatteryCharger_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BatteryState_BatteryCharger_BatteryState_BatteryCharger_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BatteryState_BatteryCharger_IsValid(int value);
constexpr BatteryState_BatteryCharger BatteryState_BatteryCharger_BatteryCharger_MIN = BatteryState_BatteryCharger_NONE;
constexpr BatteryState_BatteryCharger BatteryState_BatteryCharger_BatteryCharger_MAX = BatteryState_BatteryCharger_WIRELESS;
constexpr int BatteryState_BatteryCharger_BatteryCharger_ARRAYSIZE = BatteryState_BatteryCharger_BatteryCharger_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatteryState_BatteryCharger_descriptor();
template<typename T>
inline const std::string& BatteryState_BatteryCharger_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryState_BatteryCharger>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryState_BatteryCharger_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatteryState_BatteryCharger_descriptor(), enum_t_value);
}
inline bool BatteryState_BatteryCharger_Parse(
    const std::string& name, BatteryState_BatteryCharger* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatteryState_BatteryCharger>(
    BatteryState_BatteryCharger_descriptor(), name, value);
}
enum BatteryState_BatteryHealth : int {
  BatteryState_BatteryHealth_GOOD = 0,
  BatteryState_BatteryHealth_FAILED = 1,
  BatteryState_BatteryHealth_DEAD = 2,
  BatteryState_BatteryHealth_OVERVOLTAGE = 3,
  BatteryState_BatteryHealth_OVERHEATED = 4,
  BatteryState_BatteryHealth_BatteryState_BatteryHealth_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BatteryState_BatteryHealth_BatteryState_BatteryHealth_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BatteryState_BatteryHealth_IsValid(int value);
constexpr BatteryState_BatteryHealth BatteryState_BatteryHealth_BatteryHealth_MIN = BatteryState_BatteryHealth_GOOD;
constexpr BatteryState_BatteryHealth BatteryState_BatteryHealth_BatteryHealth_MAX = BatteryState_BatteryHealth_OVERHEATED;
constexpr int BatteryState_BatteryHealth_BatteryHealth_ARRAYSIZE = BatteryState_BatteryHealth_BatteryHealth_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatteryState_BatteryHealth_descriptor();
template<typename T>
inline const std::string& BatteryState_BatteryHealth_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryState_BatteryHealth>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryState_BatteryHealth_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatteryState_BatteryHealth_descriptor(), enum_t_value);
}
inline bool BatteryState_BatteryHealth_Parse(
    const std::string& name, BatteryState_BatteryHealth* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatteryState_BatteryHealth>(
    BatteryState_BatteryHealth_descriptor(), name, value);
}
enum ImageTransport_TransportChannel : int {
  ImageTransport_TransportChannel_TRANSPORT_CHANNEL_UNSPECIFIED = 0,
  ImageTransport_TransportChannel_MMAP = 1,
  ImageTransport_TransportChannel_ImageTransport_TransportChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImageTransport_TransportChannel_ImageTransport_TransportChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImageTransport_TransportChannel_IsValid(int value);
constexpr ImageTransport_TransportChannel ImageTransport_TransportChannel_TransportChannel_MIN = ImageTransport_TransportChannel_TRANSPORT_CHANNEL_UNSPECIFIED;
constexpr ImageTransport_TransportChannel ImageTransport_TransportChannel_TransportChannel_MAX = ImageTransport_TransportChannel_MMAP;
constexpr int ImageTransport_TransportChannel_TransportChannel_ARRAYSIZE = ImageTransport_TransportChannel_TransportChannel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageTransport_TransportChannel_descriptor();
template<typename T>
inline const std::string& ImageTransport_TransportChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageTransport_TransportChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageTransport_TransportChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageTransport_TransportChannel_descriptor(), enum_t_value);
}
inline bool ImageTransport_TransportChannel_Parse(
    const std::string& name, ImageTransport_TransportChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageTransport_TransportChannel>(
    ImageTransport_TransportChannel_descriptor(), name, value);
}
enum ImageFormat_ImgFormat : int {
  ImageFormat_ImgFormat_PNG = 0,
  ImageFormat_ImgFormat_RGBA8888 = 1,
  ImageFormat_ImgFormat_RGB888 = 2,
  ImageFormat_ImgFormat_ImageFormat_ImgFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImageFormat_ImgFormat_ImageFormat_ImgFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImageFormat_ImgFormat_IsValid(int value);
constexpr ImageFormat_ImgFormat ImageFormat_ImgFormat_ImgFormat_MIN = ImageFormat_ImgFormat_PNG;
constexpr ImageFormat_ImgFormat ImageFormat_ImgFormat_ImgFormat_MAX = ImageFormat_ImgFormat_RGB888;
constexpr int ImageFormat_ImgFormat_ImgFormat_ARRAYSIZE = ImageFormat_ImgFormat_ImgFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFormat_ImgFormat_descriptor();
template<typename T>
inline const std::string& ImageFormat_ImgFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageFormat_ImgFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageFormat_ImgFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageFormat_ImgFormat_descriptor(), enum_t_value);
}
inline bool ImageFormat_ImgFormat_Parse(
    const std::string& name, ImageFormat_ImgFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageFormat_ImgFormat>(
    ImageFormat_ImgFormat_descriptor(), name, value);
}
enum Rotation_SkinRotation : int {
  Rotation_SkinRotation_PORTRAIT = 0,
  Rotation_SkinRotation_LANDSCAPE = 1,
  Rotation_SkinRotation_REVERSE_PORTRAIT = 2,
  Rotation_SkinRotation_REVERSE_LANDSCAPE = 3,
  Rotation_SkinRotation_Rotation_SkinRotation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Rotation_SkinRotation_Rotation_SkinRotation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Rotation_SkinRotation_IsValid(int value);
constexpr Rotation_SkinRotation Rotation_SkinRotation_SkinRotation_MIN = Rotation_SkinRotation_PORTRAIT;
constexpr Rotation_SkinRotation Rotation_SkinRotation_SkinRotation_MAX = Rotation_SkinRotation_REVERSE_LANDSCAPE;
constexpr int Rotation_SkinRotation_SkinRotation_ARRAYSIZE = Rotation_SkinRotation_SkinRotation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Rotation_SkinRotation_descriptor();
template<typename T>
inline const std::string& Rotation_SkinRotation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Rotation_SkinRotation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Rotation_SkinRotation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Rotation_SkinRotation_descriptor(), enum_t_value);
}
inline bool Rotation_SkinRotation_Parse(
    const std::string& name, Rotation_SkinRotation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Rotation_SkinRotation>(
    Rotation_SkinRotation_descriptor(), name, value);
}
enum PhoneCall_Operation : int {
  PhoneCall_Operation_InitCall = 0,
  PhoneCall_Operation_AcceptCall = 1,
  PhoneCall_Operation_RejectCallExplicit = 2,
  PhoneCall_Operation_RejectCallBusy = 3,
  PhoneCall_Operation_DisconnectCall = 4,
  PhoneCall_Operation_PlaceCallOnHold = 5,
  PhoneCall_Operation_TakeCallOffHold = 6,
  PhoneCall_Operation_PhoneCall_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PhoneCall_Operation_PhoneCall_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PhoneCall_Operation_IsValid(int value);
constexpr PhoneCall_Operation PhoneCall_Operation_Operation_MIN = PhoneCall_Operation_InitCall;
constexpr PhoneCall_Operation PhoneCall_Operation_Operation_MAX = PhoneCall_Operation_TakeCallOffHold;
constexpr int PhoneCall_Operation_Operation_ARRAYSIZE = PhoneCall_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PhoneCall_Operation_descriptor();
template<typename T>
inline const std::string& PhoneCall_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PhoneCall_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PhoneCall_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PhoneCall_Operation_descriptor(), enum_t_value);
}
inline bool PhoneCall_Operation_Parse(
    const std::string& name, PhoneCall_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhoneCall_Operation>(
    PhoneCall_Operation_descriptor(), name, value);
}
enum PhoneResponse_Response : int {
  PhoneResponse_Response_OK = 0,
  PhoneResponse_Response_BadOperation = 1,
  PhoneResponse_Response_BadNumber = 2,
  PhoneResponse_Response_InvalidAction = 3,
  PhoneResponse_Response_ActionFailed = 4,
  PhoneResponse_Response_RadioOff = 5,
  PhoneResponse_Response_PhoneResponse_Response_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PhoneResponse_Response_PhoneResponse_Response_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PhoneResponse_Response_IsValid(int value);
constexpr PhoneResponse_Response PhoneResponse_Response_Response_MIN = PhoneResponse_Response_OK;
constexpr PhoneResponse_Response PhoneResponse_Response_Response_MAX = PhoneResponse_Response_RadioOff;
constexpr int PhoneResponse_Response_Response_ARRAYSIZE = PhoneResponse_Response_Response_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PhoneResponse_Response_descriptor();
template<typename T>
inline const std::string& PhoneResponse_Response_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PhoneResponse_Response>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PhoneResponse_Response_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PhoneResponse_Response_descriptor(), enum_t_value);
}
inline bool PhoneResponse_Response_Parse(
    const std::string& name, PhoneResponse_Response* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhoneResponse_Response>(
    PhoneResponse_Response_descriptor(), name, value);
}
enum AudioFormat_SampleFormat : int {
  AudioFormat_SampleFormat_AUD_FMT_U8 = 0,
  AudioFormat_SampleFormat_AUD_FMT_S16 = 1,
  AudioFormat_SampleFormat_AudioFormat_SampleFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioFormat_SampleFormat_AudioFormat_SampleFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioFormat_SampleFormat_IsValid(int value);
constexpr AudioFormat_SampleFormat AudioFormat_SampleFormat_SampleFormat_MIN = AudioFormat_SampleFormat_AUD_FMT_U8;
constexpr AudioFormat_SampleFormat AudioFormat_SampleFormat_SampleFormat_MAX = AudioFormat_SampleFormat_AUD_FMT_S16;
constexpr int AudioFormat_SampleFormat_SampleFormat_ARRAYSIZE = AudioFormat_SampleFormat_SampleFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioFormat_SampleFormat_descriptor();
template<typename T>
inline const std::string& AudioFormat_SampleFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioFormat_SampleFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioFormat_SampleFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioFormat_SampleFormat_descriptor(), enum_t_value);
}
inline bool AudioFormat_SampleFormat_Parse(
    const std::string& name, AudioFormat_SampleFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioFormat_SampleFormat>(
    AudioFormat_SampleFormat_descriptor(), name, value);
}
enum AudioFormat_Channels : int {
  AudioFormat_Channels_Mono = 0,
  AudioFormat_Channels_Stereo = 1,
  AudioFormat_Channels_AudioFormat_Channels_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioFormat_Channels_AudioFormat_Channels_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioFormat_Channels_IsValid(int value);
constexpr AudioFormat_Channels AudioFormat_Channels_Channels_MIN = AudioFormat_Channels_Mono;
constexpr AudioFormat_Channels AudioFormat_Channels_Channels_MAX = AudioFormat_Channels_Stereo;
constexpr int AudioFormat_Channels_Channels_ARRAYSIZE = AudioFormat_Channels_Channels_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioFormat_Channels_descriptor();
template<typename T>
inline const std::string& AudioFormat_Channels_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioFormat_Channels>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioFormat_Channels_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioFormat_Channels_descriptor(), enum_t_value);
}
inline bool AudioFormat_Channels_Parse(
    const std::string& name, AudioFormat_Channels* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioFormat_Channels>(
    AudioFormat_Channels_descriptor(), name, value);
}
// ===================================================================

class VmRunState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.VmRunState) */ {
 public:
  VmRunState();
  virtual ~VmRunState();

  VmRunState(const VmRunState& from);
  VmRunState(VmRunState&& from) noexcept
    : VmRunState() {
    *this = ::std::move(from);
  }

  inline VmRunState& operator=(const VmRunState& from) {
    CopyFrom(from);
    return *this;
  }
  inline VmRunState& operator=(VmRunState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VmRunState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VmRunState* internal_default_instance() {
    return reinterpret_cast<const VmRunState*>(
               &_VmRunState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VmRunState& a, VmRunState& b) {
    a.Swap(&b);
  }
  inline void Swap(VmRunState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VmRunState* New() const final {
    return CreateMaybeMessage<VmRunState>(nullptr);
  }

  VmRunState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VmRunState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VmRunState& from);
  void MergeFrom(const VmRunState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VmRunState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.VmRunState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VmRunState_RunState RunState;
  static constexpr RunState UNKNOWN =
    VmRunState_RunState_UNKNOWN;
  static constexpr RunState RUNNING =
    VmRunState_RunState_RUNNING;
  static constexpr RunState RESTORE_VM =
    VmRunState_RunState_RESTORE_VM;
  static constexpr RunState PAUSED =
    VmRunState_RunState_PAUSED;
  static constexpr RunState SAVE_VM =
    VmRunState_RunState_SAVE_VM;
  static constexpr RunState SHUTDOWN =
    VmRunState_RunState_SHUTDOWN;
  static constexpr RunState TERMINATE =
    VmRunState_RunState_TERMINATE;
  static constexpr RunState RESET =
    VmRunState_RunState_RESET;
  static constexpr RunState INTERNAL_ERROR =
    VmRunState_RunState_INTERNAL_ERROR;
  static inline bool RunState_IsValid(int value) {
    return VmRunState_RunState_IsValid(value);
  }
  static constexpr RunState RunState_MIN =
    VmRunState_RunState_RunState_MIN;
  static constexpr RunState RunState_MAX =
    VmRunState_RunState_RunState_MAX;
  static constexpr int RunState_ARRAYSIZE =
    VmRunState_RunState_RunState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RunState_descriptor() {
    return VmRunState_RunState_descriptor();
  }
  template<typename T>
  static inline const std::string& RunState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RunState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RunState_Name.");
    return VmRunState_RunState_Name(enum_t_value);
  }
  static inline bool RunState_Parse(const std::string& name,
      RunState* value) {
    return VmRunState_RunState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .android.emulation.control.VmRunState.RunState state = 1;
  void clear_state();
  ::android::emulation::control::VmRunState_RunState state() const;
  void set_state(::android::emulation::control::VmRunState_RunState value);
  private:
  ::android::emulation::control::VmRunState_RunState _internal_state() const;
  void _internal_set_state(::android::emulation::control::VmRunState_RunState value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.VmRunState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class ParameterValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.ParameterValue) */ {
 public:
  ParameterValue();
  virtual ~ParameterValue();

  ParameterValue(const ParameterValue& from);
  ParameterValue(ParameterValue&& from) noexcept
    : ParameterValue() {
    *this = ::std::move(from);
  }

  inline ParameterValue& operator=(const ParameterValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParameterValue& operator=(ParameterValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ParameterValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParameterValue* internal_default_instance() {
    return reinterpret_cast<const ParameterValue*>(
               &_ParameterValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ParameterValue& a, ParameterValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ParameterValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParameterValue* New() const final {
    return CreateMaybeMessage<ParameterValue>(nullptr);
  }

  ParameterValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParameterValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ParameterValue& from);
  void MergeFrom(const ParameterValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParameterValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.ParameterValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated float data = 1 [packed = true];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:android.emulation.control.ParameterValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class PhysicalModelValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.PhysicalModelValue) */ {
 public:
  PhysicalModelValue();
  virtual ~PhysicalModelValue();

  PhysicalModelValue(const PhysicalModelValue& from);
  PhysicalModelValue(PhysicalModelValue&& from) noexcept
    : PhysicalModelValue() {
    *this = ::std::move(from);
  }

  inline PhysicalModelValue& operator=(const PhysicalModelValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicalModelValue& operator=(PhysicalModelValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhysicalModelValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicalModelValue* internal_default_instance() {
    return reinterpret_cast<const PhysicalModelValue*>(
               &_PhysicalModelValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PhysicalModelValue& a, PhysicalModelValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicalModelValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhysicalModelValue* New() const final {
    return CreateMaybeMessage<PhysicalModelValue>(nullptr);
  }

  PhysicalModelValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhysicalModelValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhysicalModelValue& from);
  void MergeFrom(const PhysicalModelValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalModelValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.PhysicalModelValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PhysicalModelValue_State State;
  static constexpr State OK =
    PhysicalModelValue_State_OK;
  static constexpr State NO_SERVICE =
    PhysicalModelValue_State_NO_SERVICE;
  static constexpr State DISABLED =
    PhysicalModelValue_State_DISABLED;
  static constexpr State UNKNOWN =
    PhysicalModelValue_State_UNKNOWN;
  static inline bool State_IsValid(int value) {
    return PhysicalModelValue_State_IsValid(value);
  }
  static constexpr State State_MIN =
    PhysicalModelValue_State_State_MIN;
  static constexpr State State_MAX =
    PhysicalModelValue_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    PhysicalModelValue_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return PhysicalModelValue_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return PhysicalModelValue_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return PhysicalModelValue_State_Parse(name, value);
  }

  typedef PhysicalModelValue_PhysicalType PhysicalType;
  static constexpr PhysicalType POSITION =
    PhysicalModelValue_PhysicalType_POSITION;
  static constexpr PhysicalType ROTATION =
    PhysicalModelValue_PhysicalType_ROTATION;
  static constexpr PhysicalType MAGNETIC_FIELD =
    PhysicalModelValue_PhysicalType_MAGNETIC_FIELD;
  static constexpr PhysicalType TEMPERATURE =
    PhysicalModelValue_PhysicalType_TEMPERATURE;
  static constexpr PhysicalType PROXIMITY =
    PhysicalModelValue_PhysicalType_PROXIMITY;
  static constexpr PhysicalType LIGHT =
    PhysicalModelValue_PhysicalType_LIGHT;
  static constexpr PhysicalType PRESSURE =
    PhysicalModelValue_PhysicalType_PRESSURE;
  static constexpr PhysicalType HUMIDITY =
    PhysicalModelValue_PhysicalType_HUMIDITY;
  static constexpr PhysicalType VELOCITY =
    PhysicalModelValue_PhysicalType_VELOCITY;
  static constexpr PhysicalType AMBIENT_MOTION =
    PhysicalModelValue_PhysicalType_AMBIENT_MOTION;
  static inline bool PhysicalType_IsValid(int value) {
    return PhysicalModelValue_PhysicalType_IsValid(value);
  }
  static constexpr PhysicalType PhysicalType_MIN =
    PhysicalModelValue_PhysicalType_PhysicalType_MIN;
  static constexpr PhysicalType PhysicalType_MAX =
    PhysicalModelValue_PhysicalType_PhysicalType_MAX;
  static constexpr int PhysicalType_ARRAYSIZE =
    PhysicalModelValue_PhysicalType_PhysicalType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PhysicalType_descriptor() {
    return PhysicalModelValue_PhysicalType_descriptor();
  }
  template<typename T>
  static inline const std::string& PhysicalType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PhysicalType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PhysicalType_Name.");
    return PhysicalModelValue_PhysicalType_Name(enum_t_value);
  }
  static inline bool PhysicalType_Parse(const std::string& name,
      PhysicalType* value) {
    return PhysicalModelValue_PhysicalType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kTargetFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .android.emulation.control.ParameterValue value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::android::emulation::control::ParameterValue& value() const;
  ::android::emulation::control::ParameterValue* release_value();
  ::android::emulation::control::ParameterValue* mutable_value();
  void set_allocated_value(::android::emulation::control::ParameterValue* value);
  private:
  const ::android::emulation::control::ParameterValue& _internal_value() const;
  ::android::emulation::control::ParameterValue* _internal_mutable_value();
  public:

  // .android.emulation.control.PhysicalModelValue.PhysicalType target = 1;
  void clear_target();
  ::android::emulation::control::PhysicalModelValue_PhysicalType target() const;
  void set_target(::android::emulation::control::PhysicalModelValue_PhysicalType value);
  private:
  ::android::emulation::control::PhysicalModelValue_PhysicalType _internal_target() const;
  void _internal_set_target(::android::emulation::control::PhysicalModelValue_PhysicalType value);
  public:

  // .android.emulation.control.PhysicalModelValue.State status = 2;
  void clear_status();
  ::android::emulation::control::PhysicalModelValue_State status() const;
  void set_status(::android::emulation::control::PhysicalModelValue_State value);
  private:
  ::android::emulation::control::PhysicalModelValue_State _internal_status() const;
  void _internal_set_status(::android::emulation::control::PhysicalModelValue_State value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.PhysicalModelValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::android::emulation::control::ParameterValue* value_;
  int target_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class SensorValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.SensorValue) */ {
 public:
  SensorValue();
  virtual ~SensorValue();

  SensorValue(const SensorValue& from);
  SensorValue(SensorValue&& from) noexcept
    : SensorValue() {
    *this = ::std::move(from);
  }

  inline SensorValue& operator=(const SensorValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorValue& operator=(SensorValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorValue* internal_default_instance() {
    return reinterpret_cast<const SensorValue*>(
               &_SensorValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SensorValue& a, SensorValue& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorValue* New() const final {
    return CreateMaybeMessage<SensorValue>(nullptr);
  }

  SensorValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorValue& from);
  void MergeFrom(const SensorValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.SensorValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SensorValue_State State;
  static constexpr State OK =
    SensorValue_State_OK;
  static constexpr State NO_SERVICE =
    SensorValue_State_NO_SERVICE;
  static constexpr State DISABLED =
    SensorValue_State_DISABLED;
  static constexpr State UNKNOWN =
    SensorValue_State_UNKNOWN;
  static inline bool State_IsValid(int value) {
    return SensorValue_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SensorValue_State_State_MIN;
  static constexpr State State_MAX =
    SensorValue_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SensorValue_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SensorValue_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SensorValue_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return SensorValue_State_Parse(name, value);
  }

  typedef SensorValue_SensorType SensorType;
  static constexpr SensorType ACCELERATION =
    SensorValue_SensorType_ACCELERATION;
  static constexpr SensorType GYROSCOPE =
    SensorValue_SensorType_GYROSCOPE;
  static constexpr SensorType MAGNETIC_FIELD =
    SensorValue_SensorType_MAGNETIC_FIELD;
  static constexpr SensorType ORIENTATION =
    SensorValue_SensorType_ORIENTATION;
  static constexpr SensorType TEMPERATURE =
    SensorValue_SensorType_TEMPERATURE;
  static constexpr SensorType PROXIMITY =
    SensorValue_SensorType_PROXIMITY;
  static constexpr SensorType LIGHT =
    SensorValue_SensorType_LIGHT;
  static constexpr SensorType PRESSURE =
    SensorValue_SensorType_PRESSURE;
  static constexpr SensorType HUMIDITY =
    SensorValue_SensorType_HUMIDITY;
  static constexpr SensorType MAGNETIC_FIELD_UNCALIBRATED =
    SensorValue_SensorType_MAGNETIC_FIELD_UNCALIBRATED;
  static constexpr SensorType GYROSCOPE_UNCALIBRATED =
    SensorValue_SensorType_GYROSCOPE_UNCALIBRATED;
  static inline bool SensorType_IsValid(int value) {
    return SensorValue_SensorType_IsValid(value);
  }
  static constexpr SensorType SensorType_MIN =
    SensorValue_SensorType_SensorType_MIN;
  static constexpr SensorType SensorType_MAX =
    SensorValue_SensorType_SensorType_MAX;
  static constexpr int SensorType_ARRAYSIZE =
    SensorValue_SensorType_SensorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SensorType_descriptor() {
    return SensorValue_SensorType_descriptor();
  }
  template<typename T>
  static inline const std::string& SensorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SensorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SensorType_Name.");
    return SensorValue_SensorType_Name(enum_t_value);
  }
  static inline bool SensorType_Parse(const std::string& name,
      SensorType* value) {
    return SensorValue_SensorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kTargetFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .android.emulation.control.ParameterValue value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::android::emulation::control::ParameterValue& value() const;
  ::android::emulation::control::ParameterValue* release_value();
  ::android::emulation::control::ParameterValue* mutable_value();
  void set_allocated_value(::android::emulation::control::ParameterValue* value);
  private:
  const ::android::emulation::control::ParameterValue& _internal_value() const;
  ::android::emulation::control::ParameterValue* _internal_mutable_value();
  public:

  // .android.emulation.control.SensorValue.SensorType target = 1;
  void clear_target();
  ::android::emulation::control::SensorValue_SensorType target() const;
  void set_target(::android::emulation::control::SensorValue_SensorType value);
  private:
  ::android::emulation::control::SensorValue_SensorType _internal_target() const;
  void _internal_set_target(::android::emulation::control::SensorValue_SensorType value);
  public:

  // .android.emulation.control.SensorValue.State status = 2;
  void clear_status();
  ::android::emulation::control::SensorValue_State status() const;
  void set_status(::android::emulation::control::SensorValue_State value);
  private:
  ::android::emulation::control::SensorValue_State _internal_status() const;
  void _internal_set_status(::android::emulation::control::SensorValue_State value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.SensorValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::android::emulation::control::ParameterValue* value_;
  int target_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class LogMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.LogMessage) */ {
 public:
  LogMessage();
  virtual ~LogMessage();

  LogMessage(const LogMessage& from);
  LogMessage(LogMessage&& from) noexcept
    : LogMessage() {
    *this = ::std::move(from);
  }

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogMessage& operator=(LogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogMessage* internal_default_instance() {
    return reinterpret_cast<const LogMessage*>(
               &_LogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogMessage& a, LogMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LogMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogMessage* New() const final {
    return CreateMaybeMessage<LogMessage>(nullptr);
  }

  LogMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.LogMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LogMessage_LogType LogType;
  static constexpr LogType Text =
    LogMessage_LogType_Text;
  static constexpr LogType Parsed =
    LogMessage_LogType_Parsed;
  static inline bool LogType_IsValid(int value) {
    return LogMessage_LogType_IsValid(value);
  }
  static constexpr LogType LogType_MIN =
    LogMessage_LogType_LogType_MIN;
  static constexpr LogType LogType_MAX =
    LogMessage_LogType_LogType_MAX;
  static constexpr int LogType_ARRAYSIZE =
    LogMessage_LogType_LogType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LogType_descriptor() {
    return LogMessage_LogType_descriptor();
  }
  template<typename T>
  static inline const std::string& LogType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogType_Name.");
    return LogMessage_LogType_Name(enum_t_value);
  }
  static inline bool LogType_Parse(const std::string& name,
      LogType* value) {
    return LogMessage_LogType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 5,
    kContentsFieldNumber = 1,
    kStartFieldNumber = 2,
    kNextFieldNumber = 3,
    kSortFieldNumber = 4,
  };
  // repeated .android.emulation.control.LogcatEntry entries = 5;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::android::emulation::control::LogcatEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::LogcatEntry >*
      mutable_entries();
  private:
  const ::android::emulation::control::LogcatEntry& _internal_entries(int index) const;
  ::android::emulation::control::LogcatEntry* _internal_add_entries();
  public:
  const ::android::emulation::control::LogcatEntry& entries(int index) const;
  ::android::emulation::control::LogcatEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::LogcatEntry >&
      entries() const;

  // string contents = 1;
  void clear_contents();
  const std::string& contents() const;
  void set_contents(const std::string& value);
  void set_contents(std::string&& value);
  void set_contents(const char* value);
  void set_contents(const char* value, size_t size);
  std::string* mutable_contents();
  std::string* release_contents();
  void set_allocated_contents(std::string* contents);
  private:
  const std::string& _internal_contents() const;
  void _internal_set_contents(const std::string& value);
  std::string* _internal_mutable_contents();
  public:

  // int64 start = 2;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int64 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 next = 3;
  void clear_next();
  ::PROTOBUF_NAMESPACE_ID::int64 next() const;
  void set_next(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_next() const;
  void _internal_set_next(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .android.emulation.control.LogMessage.LogType sort = 4;
  void clear_sort();
  ::android::emulation::control::LogMessage_LogType sort() const;
  void set_sort(::android::emulation::control::LogMessage_LogType value);
  private:
  ::android::emulation::control::LogMessage_LogType _internal_sort() const;
  void _internal_set_sort(::android::emulation::control::LogMessage_LogType value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.LogMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::LogcatEntry > entries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_;
  ::PROTOBUF_NAMESPACE_ID::int64 next_;
  int sort_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class LogcatEntry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.LogcatEntry) */ {
 public:
  LogcatEntry();
  virtual ~LogcatEntry();

  LogcatEntry(const LogcatEntry& from);
  LogcatEntry(LogcatEntry&& from) noexcept
    : LogcatEntry() {
    *this = ::std::move(from);
  }

  inline LogcatEntry& operator=(const LogcatEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogcatEntry& operator=(LogcatEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogcatEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogcatEntry* internal_default_instance() {
    return reinterpret_cast<const LogcatEntry*>(
               &_LogcatEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogcatEntry& a, LogcatEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LogcatEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogcatEntry* New() const final {
    return CreateMaybeMessage<LogcatEntry>(nullptr);
  }

  LogcatEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogcatEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogcatEntry& from);
  void MergeFrom(const LogcatEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogcatEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.LogcatEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LogcatEntry_LogLevel LogLevel;
  static constexpr LogLevel UNKNOWN =
    LogcatEntry_LogLevel_UNKNOWN;
  static constexpr LogLevel DEFAULT =
    LogcatEntry_LogLevel_DEFAULT;
  static constexpr LogLevel VERBOSE =
    LogcatEntry_LogLevel_VERBOSE;
  static constexpr LogLevel DEBUG =
    LogcatEntry_LogLevel_DEBUG;
  static constexpr LogLevel INFO =
    LogcatEntry_LogLevel_INFO;
  static constexpr LogLevel WARN =
    LogcatEntry_LogLevel_WARN;
  static constexpr LogLevel ERR =
    LogcatEntry_LogLevel_ERR;
  static constexpr LogLevel FATAL =
    LogcatEntry_LogLevel_FATAL;
  static constexpr LogLevel SILENT =
    LogcatEntry_LogLevel_SILENT;
  static inline bool LogLevel_IsValid(int value) {
    return LogcatEntry_LogLevel_IsValid(value);
  }
  static constexpr LogLevel LogLevel_MIN =
    LogcatEntry_LogLevel_LogLevel_MIN;
  static constexpr LogLevel LogLevel_MAX =
    LogcatEntry_LogLevel_LogLevel_MAX;
  static constexpr int LogLevel_ARRAYSIZE =
    LogcatEntry_LogLevel_LogLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LogLevel_descriptor() {
    return LogcatEntry_LogLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& LogLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogLevel_Name.");
    return LogcatEntry_LogLevel_Name(enum_t_value);
  }
  static inline bool LogLevel_Parse(const std::string& name,
      LogLevel* value) {
    return LogcatEntry_LogLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 5,
    kMsgFieldNumber = 6,
    kTimestampFieldNumber = 1,
    kPidFieldNumber = 2,
    kTidFieldNumber = 3,
    kLevelFieldNumber = 4,
  };
  // string tag = 5;
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string msg = 6;
  void clear_msg();
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 timestamp = 1;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 pid = 2;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::uint32 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 tid = 3;
  void clear_tid();
  ::PROTOBUF_NAMESPACE_ID::uint32 tid() const;
  void set_tid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tid() const;
  void _internal_set_tid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .android.emulation.control.LogcatEntry.LogLevel level = 4;
  void clear_level();
  ::android::emulation::control::LogcatEntry_LogLevel level() const;
  void set_level(::android::emulation::control::LogcatEntry_LogLevel value);
  private:
  ::android::emulation::control::LogcatEntry_LogLevel _internal_level() const;
  void _internal_set_level(::android::emulation::control::LogcatEntry_LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.LogcatEntry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tid_;
  int level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class VmConfiguration :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.VmConfiguration) */ {
 public:
  VmConfiguration();
  virtual ~VmConfiguration();

  VmConfiguration(const VmConfiguration& from);
  VmConfiguration(VmConfiguration&& from) noexcept
    : VmConfiguration() {
    *this = ::std::move(from);
  }

  inline VmConfiguration& operator=(const VmConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline VmConfiguration& operator=(VmConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VmConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VmConfiguration* internal_default_instance() {
    return reinterpret_cast<const VmConfiguration*>(
               &_VmConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VmConfiguration& a, VmConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(VmConfiguration* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VmConfiguration* New() const final {
    return CreateMaybeMessage<VmConfiguration>(nullptr);
  }

  VmConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VmConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VmConfiguration& from);
  void MergeFrom(const VmConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VmConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.VmConfiguration";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VmConfiguration_VmHypervisorType VmHypervisorType;
  static constexpr VmHypervisorType UNKNOWN =
    VmConfiguration_VmHypervisorType_UNKNOWN;
  static constexpr VmHypervisorType NONE =
    VmConfiguration_VmHypervisorType_NONE;
  static constexpr VmHypervisorType KVM =
    VmConfiguration_VmHypervisorType_KVM;
  static constexpr VmHypervisorType HAXM =
    VmConfiguration_VmHypervisorType_HAXM;
  static constexpr VmHypervisorType HVF =
    VmConfiguration_VmHypervisorType_HVF;
  static constexpr VmHypervisorType WHPX =
    VmConfiguration_VmHypervisorType_WHPX;
  static constexpr VmHypervisorType GVM =
    VmConfiguration_VmHypervisorType_GVM;
  static inline bool VmHypervisorType_IsValid(int value) {
    return VmConfiguration_VmHypervisorType_IsValid(value);
  }
  static constexpr VmHypervisorType VmHypervisorType_MIN =
    VmConfiguration_VmHypervisorType_VmHypervisorType_MIN;
  static constexpr VmHypervisorType VmHypervisorType_MAX =
    VmConfiguration_VmHypervisorType_VmHypervisorType_MAX;
  static constexpr int VmHypervisorType_ARRAYSIZE =
    VmConfiguration_VmHypervisorType_VmHypervisorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VmHypervisorType_descriptor() {
    return VmConfiguration_VmHypervisorType_descriptor();
  }
  template<typename T>
  static inline const std::string& VmHypervisorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VmHypervisorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VmHypervisorType_Name.");
    return VmConfiguration_VmHypervisorType_Name(enum_t_value);
  }
  static inline bool VmHypervisorType_Parse(const std::string& name,
      VmHypervisorType* value) {
    return VmConfiguration_VmHypervisorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHypervisorTypeFieldNumber = 1,
    kNumberOfCpuCoresFieldNumber = 2,
    kRamSizeBytesFieldNumber = 3,
  };
  // .android.emulation.control.VmConfiguration.VmHypervisorType hypervisorType = 1;
  void clear_hypervisortype();
  ::android::emulation::control::VmConfiguration_VmHypervisorType hypervisortype() const;
  void set_hypervisortype(::android::emulation::control::VmConfiguration_VmHypervisorType value);
  private:
  ::android::emulation::control::VmConfiguration_VmHypervisorType _internal_hypervisortype() const;
  void _internal_set_hypervisortype(::android::emulation::control::VmConfiguration_VmHypervisorType value);
  public:

  // int32 numberOfCpuCores = 2;
  void clear_numberofcpucores();
  ::PROTOBUF_NAMESPACE_ID::int32 numberofcpucores() const;
  void set_numberofcpucores(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_numberofcpucores() const;
  void _internal_set_numberofcpucores(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 ramSizeBytes = 3;
  void clear_ramsizebytes();
  ::PROTOBUF_NAMESPACE_ID::int64 ramsizebytes() const;
  void set_ramsizebytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ramsizebytes() const;
  void _internal_set_ramsizebytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.VmConfiguration)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int hypervisortype_;
  ::PROTOBUF_NAMESPACE_ID::int32 numberofcpucores_;
  ::PROTOBUF_NAMESPACE_ID::int64 ramsizebytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class ClipData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.ClipData) */ {
 public:
  ClipData();
  virtual ~ClipData();

  ClipData(const ClipData& from);
  ClipData(ClipData&& from) noexcept
    : ClipData() {
    *this = ::std::move(from);
  }

  inline ClipData& operator=(const ClipData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClipData& operator=(ClipData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClipData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClipData* internal_default_instance() {
    return reinterpret_cast<const ClipData*>(
               &_ClipData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClipData& a, ClipData& b) {
    a.Swap(&b);
  }
  inline void Swap(ClipData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClipData* New() const final {
    return CreateMaybeMessage<ClipData>(nullptr);
  }

  ClipData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClipData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClipData& from);
  void MergeFrom(const ClipData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClipData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.ClipData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.ClipData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Touch :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.Touch) */ {
 public:
  Touch();
  virtual ~Touch();

  Touch(const Touch& from);
  Touch(Touch&& from) noexcept
    : Touch() {
    *this = ::std::move(from);
  }

  inline Touch& operator=(const Touch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Touch& operator=(Touch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Touch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Touch* internal_default_instance() {
    return reinterpret_cast<const Touch*>(
               &_Touch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Touch& a, Touch& b) {
    a.Swap(&b);
  }
  inline void Swap(Touch* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Touch* New() const final {
    return CreateMaybeMessage<Touch>(nullptr);
  }

  Touch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Touch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Touch& from);
  void MergeFrom(const Touch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Touch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.Touch";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kIdentifierFieldNumber = 3,
    kPressureFieldNumber = 4,
    kTouchMajorFieldNumber = 5,
    kTouchMinorFieldNumber = 6,
  };
  // int32 x = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 identifier = 3;
  void clear_identifier();
  ::PROTOBUF_NAMESPACE_ID::int32 identifier() const;
  void set_identifier(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_identifier() const;
  void _internal_set_identifier(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 pressure = 4;
  void clear_pressure();
  ::PROTOBUF_NAMESPACE_ID::int32 pressure() const;
  void set_pressure(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pressure() const;
  void _internal_set_pressure(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 touch_major = 5;
  void clear_touch_major();
  ::PROTOBUF_NAMESPACE_ID::int32 touch_major() const;
  void set_touch_major(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_touch_major() const;
  void _internal_set_touch_major(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 touch_minor = 6;
  void clear_touch_minor();
  ::PROTOBUF_NAMESPACE_ID::int32 touch_minor() const;
  void set_touch_minor(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_touch_minor() const;
  void _internal_set_touch_minor(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.Touch)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  ::PROTOBUF_NAMESPACE_ID::int32 identifier_;
  ::PROTOBUF_NAMESPACE_ID::int32 pressure_;
  ::PROTOBUF_NAMESPACE_ID::int32 touch_major_;
  ::PROTOBUF_NAMESPACE_ID::int32 touch_minor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class TouchEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.TouchEvent) */ {
 public:
  TouchEvent();
  virtual ~TouchEvent();

  TouchEvent(const TouchEvent& from);
  TouchEvent(TouchEvent&& from) noexcept
    : TouchEvent() {
    *this = ::std::move(from);
  }

  inline TouchEvent& operator=(const TouchEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchEvent& operator=(TouchEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TouchEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TouchEvent* internal_default_instance() {
    return reinterpret_cast<const TouchEvent*>(
               &_TouchEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TouchEvent& a, TouchEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TouchEvent* New() const final {
    return CreateMaybeMessage<TouchEvent>(nullptr);
  }

  TouchEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TouchEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TouchEvent& from);
  void MergeFrom(const TouchEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.TouchEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTouchesFieldNumber = 1,
    kDeviceFieldNumber = 2,
  };
  // repeated .android.emulation.control.Touch touches = 1;
  int touches_size() const;
  private:
  int _internal_touches_size() const;
  public:
  void clear_touches();
  ::android::emulation::control::Touch* mutable_touches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Touch >*
      mutable_touches();
  private:
  const ::android::emulation::control::Touch& _internal_touches(int index) const;
  ::android::emulation::control::Touch* _internal_add_touches();
  public:
  const ::android::emulation::control::Touch& touches(int index) const;
  ::android::emulation::control::Touch* add_touches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Touch >&
      touches() const;

  // int32 device = 2;
  void clear_device();
  ::PROTOBUF_NAMESPACE_ID::int32 device() const;
  void set_device(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_device() const;
  void _internal_set_device(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.TouchEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Touch > touches_;
  ::PROTOBUF_NAMESPACE_ID::int32 device_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class MouseEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.MouseEvent) */ {
 public:
  MouseEvent();
  virtual ~MouseEvent();

  MouseEvent(const MouseEvent& from);
  MouseEvent(MouseEvent&& from) noexcept
    : MouseEvent() {
    *this = ::std::move(from);
  }

  inline MouseEvent& operator=(const MouseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseEvent& operator=(MouseEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MouseEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MouseEvent* internal_default_instance() {
    return reinterpret_cast<const MouseEvent*>(
               &_MouseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MouseEvent& a, MouseEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MouseEvent* New() const final {
    return CreateMaybeMessage<MouseEvent>(nullptr);
  }

  MouseEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MouseEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MouseEvent& from);
  void MergeFrom(const MouseEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MouseEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.MouseEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kButtonsFieldNumber = 3,
    kDeviceFieldNumber = 4,
  };
  // int32 x = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 buttons = 3;
  void clear_buttons();
  ::PROTOBUF_NAMESPACE_ID::int32 buttons() const;
  void set_buttons(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_buttons() const;
  void _internal_set_buttons(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 device = 4;
  void clear_device();
  ::PROTOBUF_NAMESPACE_ID::int32 device() const;
  void set_device(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_device() const;
  void _internal_set_device(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.MouseEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  ::PROTOBUF_NAMESPACE_ID::int32 buttons_;
  ::PROTOBUF_NAMESPACE_ID::int32 device_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class KeyboardEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.KeyboardEvent) */ {
 public:
  KeyboardEvent();
  virtual ~KeyboardEvent();

  KeyboardEvent(const KeyboardEvent& from);
  KeyboardEvent(KeyboardEvent&& from) noexcept
    : KeyboardEvent() {
    *this = ::std::move(from);
  }

  inline KeyboardEvent& operator=(const KeyboardEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyboardEvent& operator=(KeyboardEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyboardEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyboardEvent* internal_default_instance() {
    return reinterpret_cast<const KeyboardEvent*>(
               &_KeyboardEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(KeyboardEvent& a, KeyboardEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyboardEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyboardEvent* New() const final {
    return CreateMaybeMessage<KeyboardEvent>(nullptr);
  }

  KeyboardEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyboardEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyboardEvent& from);
  void MergeFrom(const KeyboardEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyboardEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.KeyboardEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef KeyboardEvent_KeyCodeType KeyCodeType;
  static constexpr KeyCodeType Usb =
    KeyboardEvent_KeyCodeType_Usb;
  static constexpr KeyCodeType Evdev =
    KeyboardEvent_KeyCodeType_Evdev;
  static constexpr KeyCodeType XKB =
    KeyboardEvent_KeyCodeType_XKB;
  static constexpr KeyCodeType Win =
    KeyboardEvent_KeyCodeType_Win;
  static constexpr KeyCodeType Mac =
    KeyboardEvent_KeyCodeType_Mac;
  static inline bool KeyCodeType_IsValid(int value) {
    return KeyboardEvent_KeyCodeType_IsValid(value);
  }
  static constexpr KeyCodeType KeyCodeType_MIN =
    KeyboardEvent_KeyCodeType_KeyCodeType_MIN;
  static constexpr KeyCodeType KeyCodeType_MAX =
    KeyboardEvent_KeyCodeType_KeyCodeType_MAX;
  static constexpr int KeyCodeType_ARRAYSIZE =
    KeyboardEvent_KeyCodeType_KeyCodeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  KeyCodeType_descriptor() {
    return KeyboardEvent_KeyCodeType_descriptor();
  }
  template<typename T>
  static inline const std::string& KeyCodeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeyCodeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeyCodeType_Name.");
    return KeyboardEvent_KeyCodeType_Name(enum_t_value);
  }
  static inline bool KeyCodeType_Parse(const std::string& name,
      KeyCodeType* value) {
    return KeyboardEvent_KeyCodeType_Parse(name, value);
  }

  typedef KeyboardEvent_KeyEventType KeyEventType;
  static constexpr KeyEventType keydown =
    KeyboardEvent_KeyEventType_keydown;
  static constexpr KeyEventType keyup =
    KeyboardEvent_KeyEventType_keyup;
  static constexpr KeyEventType keypress =
    KeyboardEvent_KeyEventType_keypress;
  static inline bool KeyEventType_IsValid(int value) {
    return KeyboardEvent_KeyEventType_IsValid(value);
  }
  static constexpr KeyEventType KeyEventType_MIN =
    KeyboardEvent_KeyEventType_KeyEventType_MIN;
  static constexpr KeyEventType KeyEventType_MAX =
    KeyboardEvent_KeyEventType_KeyEventType_MAX;
  static constexpr int KeyEventType_ARRAYSIZE =
    KeyboardEvent_KeyEventType_KeyEventType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  KeyEventType_descriptor() {
    return KeyboardEvent_KeyEventType_descriptor();
  }
  template<typename T>
  static inline const std::string& KeyEventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeyEventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeyEventType_Name.");
    return KeyboardEvent_KeyEventType_Name(enum_t_value);
  }
  static inline bool KeyEventType_Parse(const std::string& name,
      KeyEventType* value) {
    return KeyboardEvent_KeyEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 4,
    kTextFieldNumber = 5,
    kCodeTypeFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kKeyCodeFieldNumber = 3,
  };
  // string key = 4;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string text = 5;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .android.emulation.control.KeyboardEvent.KeyCodeType codeType = 1;
  void clear_codetype();
  ::android::emulation::control::KeyboardEvent_KeyCodeType codetype() const;
  void set_codetype(::android::emulation::control::KeyboardEvent_KeyCodeType value);
  private:
  ::android::emulation::control::KeyboardEvent_KeyCodeType _internal_codetype() const;
  void _internal_set_codetype(::android::emulation::control::KeyboardEvent_KeyCodeType value);
  public:

  // .android.emulation.control.KeyboardEvent.KeyEventType eventType = 2;
  void clear_eventtype();
  ::android::emulation::control::KeyboardEvent_KeyEventType eventtype() const;
  void set_eventtype(::android::emulation::control::KeyboardEvent_KeyEventType value);
  private:
  ::android::emulation::control::KeyboardEvent_KeyEventType _internal_eventtype() const;
  void _internal_set_eventtype(::android::emulation::control::KeyboardEvent_KeyEventType value);
  public:

  // int32 keyCode = 3;
  void clear_keycode();
  ::PROTOBUF_NAMESPACE_ID::int32 keycode() const;
  void set_keycode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_keycode() const;
  void _internal_set_keycode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.KeyboardEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int codetype_;
  int eventtype_;
  ::PROTOBUF_NAMESPACE_ID::int32 keycode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.Fingerprint) */ {
 public:
  Fingerprint();
  virtual ~Fingerprint();

  Fingerprint(const Fingerprint& from);
  Fingerprint(Fingerprint&& from) noexcept
    : Fingerprint() {
    *this = ::std::move(from);
  }

  inline Fingerprint& operator=(const Fingerprint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint& operator=(Fingerprint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fingerprint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fingerprint* internal_default_instance() {
    return reinterpret_cast<const Fingerprint*>(
               &_Fingerprint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Fingerprint& a, Fingerprint& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fingerprint* New() const final {
    return CreateMaybeMessage<Fingerprint>(nullptr);
  }

  Fingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fingerprint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fingerprint& from);
  void MergeFrom(const Fingerprint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fingerprint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.Fingerprint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsTouchingFieldNumber = 1,
    kTouchIdFieldNumber = 2,
  };
  // bool isTouching = 1;
  void clear_istouching();
  bool istouching() const;
  void set_istouching(bool value);
  private:
  bool _internal_istouching() const;
  void _internal_set_istouching(bool value);
  public:

  // int32 touchId = 2;
  void clear_touchid();
  ::PROTOBUF_NAMESPACE_ID::int32 touchid() const;
  void set_touchid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_touchid() const;
  void _internal_set_touchid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.Fingerprint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool istouching_;
  ::PROTOBUF_NAMESPACE_ID::int32 touchid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class GpsState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.GpsState) */ {
 public:
  GpsState();
  virtual ~GpsState();

  GpsState(const GpsState& from);
  GpsState(GpsState&& from) noexcept
    : GpsState() {
    *this = ::std::move(from);
  }

  inline GpsState& operator=(const GpsState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GpsState& operator=(GpsState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GpsState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpsState* internal_default_instance() {
    return reinterpret_cast<const GpsState*>(
               &_GpsState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GpsState& a, GpsState& b) {
    a.Swap(&b);
  }
  inline void Swap(GpsState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GpsState* New() const final {
    return CreateMaybeMessage<GpsState>(nullptr);
  }

  GpsState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GpsState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GpsState& from);
  void MergeFrom(const GpsState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GpsState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.GpsState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 2,
    kLongitudeFieldNumber = 3,
    kSpeedFieldNumber = 4,
    kPassiveUpdateFieldNumber = 1,
    kSatellitesFieldNumber = 7,
    kBearingFieldNumber = 5,
    kAltitudeFieldNumber = 6,
  };
  // double latitude = 2;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 3;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // double speed = 4;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // bool passiveUpdate = 1;
  void clear_passiveupdate();
  bool passiveupdate() const;
  void set_passiveupdate(bool value);
  private:
  bool _internal_passiveupdate() const;
  void _internal_set_passiveupdate(bool value);
  public:

  // int32 satellites = 7;
  void clear_satellites();
  ::PROTOBUF_NAMESPACE_ID::int32 satellites() const;
  void set_satellites(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_satellites() const;
  void _internal_set_satellites(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double bearing = 5;
  void clear_bearing();
  double bearing() const;
  void set_bearing(double value);
  private:
  double _internal_bearing() const;
  void _internal_set_bearing(double value);
  public:

  // double altitude = 6;
  void clear_altitude();
  double altitude() const;
  void set_altitude(double value);
  private:
  double _internal_altitude() const;
  void _internal_set_altitude(double value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.GpsState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double latitude_;
  double longitude_;
  double speed_;
  bool passiveupdate_;
  ::PROTOBUF_NAMESPACE_ID::int32 satellites_;
  double bearing_;
  double altitude_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class BatteryState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.BatteryState) */ {
 public:
  BatteryState();
  virtual ~BatteryState();

  BatteryState(const BatteryState& from);
  BatteryState(BatteryState&& from) noexcept
    : BatteryState() {
    *this = ::std::move(from);
  }

  inline BatteryState& operator=(const BatteryState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryState& operator=(BatteryState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BatteryState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatteryState* internal_default_instance() {
    return reinterpret_cast<const BatteryState*>(
               &_BatteryState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BatteryState& a, BatteryState& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatteryState* New() const final {
    return CreateMaybeMessage<BatteryState>(nullptr);
  }

  BatteryState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatteryState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatteryState& from);
  void MergeFrom(const BatteryState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.BatteryState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BatteryState_BatteryStatus BatteryStatus;
  static constexpr BatteryStatus UNKNOWN =
    BatteryState_BatteryStatus_UNKNOWN;
  static constexpr BatteryStatus CHARGING =
    BatteryState_BatteryStatus_CHARGING;
  static constexpr BatteryStatus DISCHARGING =
    BatteryState_BatteryStatus_DISCHARGING;
  static constexpr BatteryStatus NOT_CHARGING =
    BatteryState_BatteryStatus_NOT_CHARGING;
  static constexpr BatteryStatus FULL =
    BatteryState_BatteryStatus_FULL;
  static inline bool BatteryStatus_IsValid(int value) {
    return BatteryState_BatteryStatus_IsValid(value);
  }
  static constexpr BatteryStatus BatteryStatus_MIN =
    BatteryState_BatteryStatus_BatteryStatus_MIN;
  static constexpr BatteryStatus BatteryStatus_MAX =
    BatteryState_BatteryStatus_BatteryStatus_MAX;
  static constexpr int BatteryStatus_ARRAYSIZE =
    BatteryState_BatteryStatus_BatteryStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BatteryStatus_descriptor() {
    return BatteryState_BatteryStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& BatteryStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BatteryStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BatteryStatus_Name.");
    return BatteryState_BatteryStatus_Name(enum_t_value);
  }
  static inline bool BatteryStatus_Parse(const std::string& name,
      BatteryStatus* value) {
    return BatteryState_BatteryStatus_Parse(name, value);
  }

  typedef BatteryState_BatteryCharger BatteryCharger;
  static constexpr BatteryCharger NONE =
    BatteryState_BatteryCharger_NONE;
  static constexpr BatteryCharger AC =
    BatteryState_BatteryCharger_AC;
  static constexpr BatteryCharger USB =
    BatteryState_BatteryCharger_USB;
  static constexpr BatteryCharger WIRELESS =
    BatteryState_BatteryCharger_WIRELESS;
  static inline bool BatteryCharger_IsValid(int value) {
    return BatteryState_BatteryCharger_IsValid(value);
  }
  static constexpr BatteryCharger BatteryCharger_MIN =
    BatteryState_BatteryCharger_BatteryCharger_MIN;
  static constexpr BatteryCharger BatteryCharger_MAX =
    BatteryState_BatteryCharger_BatteryCharger_MAX;
  static constexpr int BatteryCharger_ARRAYSIZE =
    BatteryState_BatteryCharger_BatteryCharger_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BatteryCharger_descriptor() {
    return BatteryState_BatteryCharger_descriptor();
  }
  template<typename T>
  static inline const std::string& BatteryCharger_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BatteryCharger>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BatteryCharger_Name.");
    return BatteryState_BatteryCharger_Name(enum_t_value);
  }
  static inline bool BatteryCharger_Parse(const std::string& name,
      BatteryCharger* value) {
    return BatteryState_BatteryCharger_Parse(name, value);
  }

  typedef BatteryState_BatteryHealth BatteryHealth;
  static constexpr BatteryHealth GOOD =
    BatteryState_BatteryHealth_GOOD;
  static constexpr BatteryHealth FAILED =
    BatteryState_BatteryHealth_FAILED;
  static constexpr BatteryHealth DEAD =
    BatteryState_BatteryHealth_DEAD;
  static constexpr BatteryHealth OVERVOLTAGE =
    BatteryState_BatteryHealth_OVERVOLTAGE;
  static constexpr BatteryHealth OVERHEATED =
    BatteryState_BatteryHealth_OVERHEATED;
  static inline bool BatteryHealth_IsValid(int value) {
    return BatteryState_BatteryHealth_IsValid(value);
  }
  static constexpr BatteryHealth BatteryHealth_MIN =
    BatteryState_BatteryHealth_BatteryHealth_MIN;
  static constexpr BatteryHealth BatteryHealth_MAX =
    BatteryState_BatteryHealth_BatteryHealth_MAX;
  static constexpr int BatteryHealth_ARRAYSIZE =
    BatteryState_BatteryHealth_BatteryHealth_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BatteryHealth_descriptor() {
    return BatteryState_BatteryHealth_descriptor();
  }
  template<typename T>
  static inline const std::string& BatteryHealth_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BatteryHealth>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BatteryHealth_Name.");
    return BatteryState_BatteryHealth_Name(enum_t_value);
  }
  static inline bool BatteryHealth_Parse(const std::string& name,
      BatteryHealth* value) {
    return BatteryState_BatteryHealth_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHasBatteryFieldNumber = 1,
    kIsPresentFieldNumber = 2,
    kChargerFieldNumber = 3,
    kChargeLevelFieldNumber = 4,
    kHealthFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  // bool hasBattery = 1;
  void clear_hasbattery();
  bool hasbattery() const;
  void set_hasbattery(bool value);
  private:
  bool _internal_hasbattery() const;
  void _internal_set_hasbattery(bool value);
  public:

  // bool isPresent = 2;
  void clear_ispresent();
  bool ispresent() const;
  void set_ispresent(bool value);
  private:
  bool _internal_ispresent() const;
  void _internal_set_ispresent(bool value);
  public:

  // .android.emulation.control.BatteryState.BatteryCharger charger = 3;
  void clear_charger();
  ::android::emulation::control::BatteryState_BatteryCharger charger() const;
  void set_charger(::android::emulation::control::BatteryState_BatteryCharger value);
  private:
  ::android::emulation::control::BatteryState_BatteryCharger _internal_charger() const;
  void _internal_set_charger(::android::emulation::control::BatteryState_BatteryCharger value);
  public:

  // int32 chargeLevel = 4;
  void clear_chargelevel();
  ::PROTOBUF_NAMESPACE_ID::int32 chargelevel() const;
  void set_chargelevel(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_chargelevel() const;
  void _internal_set_chargelevel(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .android.emulation.control.BatteryState.BatteryHealth health = 5;
  void clear_health();
  ::android::emulation::control::BatteryState_BatteryHealth health() const;
  void set_health(::android::emulation::control::BatteryState_BatteryHealth value);
  private:
  ::android::emulation::control::BatteryState_BatteryHealth _internal_health() const;
  void _internal_set_health(::android::emulation::control::BatteryState_BatteryHealth value);
  public:

  // .android.emulation.control.BatteryState.BatteryStatus status = 6;
  void clear_status();
  ::android::emulation::control::BatteryState_BatteryStatus status() const;
  void set_status(::android::emulation::control::BatteryState_BatteryStatus value);
  private:
  ::android::emulation::control::BatteryState_BatteryStatus _internal_status() const;
  void _internal_set_status(::android::emulation::control::BatteryState_BatteryStatus value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.BatteryState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool hasbattery_;
  bool ispresent_;
  int charger_;
  ::PROTOBUF_NAMESPACE_ID::int32 chargelevel_;
  int health_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class ImageTransport :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.ImageTransport) */ {
 public:
  ImageTransport();
  virtual ~ImageTransport();

  ImageTransport(const ImageTransport& from);
  ImageTransport(ImageTransport&& from) noexcept
    : ImageTransport() {
    *this = ::std::move(from);
  }

  inline ImageTransport& operator=(const ImageTransport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageTransport& operator=(ImageTransport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageTransport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageTransport* internal_default_instance() {
    return reinterpret_cast<const ImageTransport*>(
               &_ImageTransport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ImageTransport& a, ImageTransport& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageTransport* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageTransport* New() const final {
    return CreateMaybeMessage<ImageTransport>(nullptr);
  }

  ImageTransport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageTransport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageTransport& from);
  void MergeFrom(const ImageTransport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageTransport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.ImageTransport";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImageTransport_TransportChannel TransportChannel;
  static constexpr TransportChannel TRANSPORT_CHANNEL_UNSPECIFIED =
    ImageTransport_TransportChannel_TRANSPORT_CHANNEL_UNSPECIFIED;
  static constexpr TransportChannel MMAP =
    ImageTransport_TransportChannel_MMAP;
  static inline bool TransportChannel_IsValid(int value) {
    return ImageTransport_TransportChannel_IsValid(value);
  }
  static constexpr TransportChannel TransportChannel_MIN =
    ImageTransport_TransportChannel_TransportChannel_MIN;
  static constexpr TransportChannel TransportChannel_MAX =
    ImageTransport_TransportChannel_TransportChannel_MAX;
  static constexpr int TransportChannel_ARRAYSIZE =
    ImageTransport_TransportChannel_TransportChannel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TransportChannel_descriptor() {
    return ImageTransport_TransportChannel_descriptor();
  }
  template<typename T>
  static inline const std::string& TransportChannel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TransportChannel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TransportChannel_Name.");
    return ImageTransport_TransportChannel_Name(enum_t_value);
  }
  static inline bool TransportChannel_Parse(const std::string& name,
      TransportChannel* value) {
    return ImageTransport_TransportChannel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 2,
    kChannelFieldNumber = 1,
  };
  // string handle = 2;
  void clear_handle();
  const std::string& handle() const;
  void set_handle(const std::string& value);
  void set_handle(std::string&& value);
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  std::string* mutable_handle();
  std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // .android.emulation.control.ImageTransport.TransportChannel channel = 1;
  void clear_channel();
  ::android::emulation::control::ImageTransport_TransportChannel channel() const;
  void set_channel(::android::emulation::control::ImageTransport_TransportChannel value);
  private:
  ::android::emulation::control::ImageTransport_TransportChannel _internal_channel() const;
  void _internal_set_channel(::android::emulation::control::ImageTransport_TransportChannel value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.ImageTransport)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
  int channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class ImageFormat :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.ImageFormat) */ {
 public:
  ImageFormat();
  virtual ~ImageFormat();

  ImageFormat(const ImageFormat& from);
  ImageFormat(ImageFormat&& from) noexcept
    : ImageFormat() {
    *this = ::std::move(from);
  }

  inline ImageFormat& operator=(const ImageFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageFormat& operator=(ImageFormat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageFormat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageFormat* internal_default_instance() {
    return reinterpret_cast<const ImageFormat*>(
               &_ImageFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ImageFormat& a, ImageFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageFormat* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageFormat* New() const final {
    return CreateMaybeMessage<ImageFormat>(nullptr);
  }

  ImageFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageFormat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageFormat& from);
  void MergeFrom(const ImageFormat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageFormat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.ImageFormat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImageFormat_ImgFormat ImgFormat;
  static constexpr ImgFormat PNG =
    ImageFormat_ImgFormat_PNG;
  static constexpr ImgFormat RGBA8888 =
    ImageFormat_ImgFormat_RGBA8888;
  static constexpr ImgFormat RGB888 =
    ImageFormat_ImgFormat_RGB888;
  static inline bool ImgFormat_IsValid(int value) {
    return ImageFormat_ImgFormat_IsValid(value);
  }
  static constexpr ImgFormat ImgFormat_MIN =
    ImageFormat_ImgFormat_ImgFormat_MIN;
  static constexpr ImgFormat ImgFormat_MAX =
    ImageFormat_ImgFormat_ImgFormat_MAX;
  static constexpr int ImgFormat_ARRAYSIZE =
    ImageFormat_ImgFormat_ImgFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImgFormat_descriptor() {
    return ImageFormat_ImgFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& ImgFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImgFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImgFormat_Name.");
    return ImageFormat_ImgFormat_Name(enum_t_value);
  }
  static inline bool ImgFormat_Parse(const std::string& name,
      ImgFormat* value) {
    return ImageFormat_ImgFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRotationFieldNumber = 2,
    kTransportFieldNumber = 6,
    kFormatFieldNumber = 1,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kDisplayFieldNumber = 5,
  };
  // .android.emulation.control.Rotation rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::android::emulation::control::Rotation& rotation() const;
  ::android::emulation::control::Rotation* release_rotation();
  ::android::emulation::control::Rotation* mutable_rotation();
  void set_allocated_rotation(::android::emulation::control::Rotation* rotation);
  private:
  const ::android::emulation::control::Rotation& _internal_rotation() const;
  ::android::emulation::control::Rotation* _internal_mutable_rotation();
  public:

  // .android.emulation.control.ImageTransport transport = 6;
  bool has_transport() const;
  private:
  bool _internal_has_transport() const;
  public:
  void clear_transport();
  const ::android::emulation::control::ImageTransport& transport() const;
  ::android::emulation::control::ImageTransport* release_transport();
  ::android::emulation::control::ImageTransport* mutable_transport();
  void set_allocated_transport(::android::emulation::control::ImageTransport* transport);
  private:
  const ::android::emulation::control::ImageTransport& _internal_transport() const;
  ::android::emulation::control::ImageTransport* _internal_mutable_transport();
  public:

  // .android.emulation.control.ImageFormat.ImgFormat format = 1;
  void clear_format();
  ::android::emulation::control::ImageFormat_ImgFormat format() const;
  void set_format(::android::emulation::control::ImageFormat_ImgFormat value);
  private:
  ::android::emulation::control::ImageFormat_ImgFormat _internal_format() const;
  void _internal_set_format(::android::emulation::control::ImageFormat_ImgFormat value);
  public:

  // uint32 width = 3;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 4;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 display = 5;
  void clear_display();
  ::PROTOBUF_NAMESPACE_ID::uint32 display() const;
  void set_display(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_display() const;
  void _internal_set_display(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.ImageFormat)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::android::emulation::control::Rotation* rotation_;
  ::android::emulation::control::ImageTransport* transport_;
  int format_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::uint32 display_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Image :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.Image";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 4,
    kFormatFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kTimestampUsFieldNumber = 6,
    kSeqFieldNumber = 5,
  };
  // bytes image = 4;
  void clear_image();
  const std::string& image() const;
  void set_image(const std::string& value);
  void set_image(std::string&& value);
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  std::string* mutable_image();
  std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // .android.emulation.control.ImageFormat format = 1;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const ::android::emulation::control::ImageFormat& format() const;
  ::android::emulation::control::ImageFormat* release_format();
  ::android::emulation::control::ImageFormat* mutable_format();
  void set_allocated_format(::android::emulation::control::ImageFormat* format);
  private:
  const ::android::emulation::control::ImageFormat& _internal_format() const;
  ::android::emulation::control::ImageFormat* _internal_mutable_format();
  public:

  // uint32 width = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_width();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  PROTOBUF_DEPRECATED void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_height();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  PROTOBUF_DEPRECATED void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint64 timestampUs = 6;
  void clear_timestampus();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestampus() const;
  void set_timestampus(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestampus() const;
  void _internal_set_timestampus(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 seq = 5;
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::uint32 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.Image)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  ::android::emulation::control::ImageFormat* format_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestampus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 seq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Rotation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.Rotation) */ {
 public:
  Rotation();
  virtual ~Rotation();

  Rotation(const Rotation& from);
  Rotation(Rotation&& from) noexcept
    : Rotation() {
    *this = ::std::move(from);
  }

  inline Rotation& operator=(const Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rotation& operator=(Rotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Rotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rotation* internal_default_instance() {
    return reinterpret_cast<const Rotation*>(
               &_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Rotation& a, Rotation& b) {
    a.Swap(&b);
  }
  inline void Swap(Rotation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Rotation* New() const final {
    return CreateMaybeMessage<Rotation>(nullptr);
  }

  Rotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Rotation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Rotation& from);
  void MergeFrom(const Rotation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rotation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.Rotation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Rotation_SkinRotation SkinRotation;
  static constexpr SkinRotation PORTRAIT =
    Rotation_SkinRotation_PORTRAIT;
  static constexpr SkinRotation LANDSCAPE =
    Rotation_SkinRotation_LANDSCAPE;
  static constexpr SkinRotation REVERSE_PORTRAIT =
    Rotation_SkinRotation_REVERSE_PORTRAIT;
  static constexpr SkinRotation REVERSE_LANDSCAPE =
    Rotation_SkinRotation_REVERSE_LANDSCAPE;
  static inline bool SkinRotation_IsValid(int value) {
    return Rotation_SkinRotation_IsValid(value);
  }
  static constexpr SkinRotation SkinRotation_MIN =
    Rotation_SkinRotation_SkinRotation_MIN;
  static constexpr SkinRotation SkinRotation_MAX =
    Rotation_SkinRotation_SkinRotation_MAX;
  static constexpr int SkinRotation_ARRAYSIZE =
    Rotation_SkinRotation_SkinRotation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SkinRotation_descriptor() {
    return Rotation_SkinRotation_descriptor();
  }
  template<typename T>
  static inline const std::string& SkinRotation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SkinRotation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SkinRotation_Name.");
    return Rotation_SkinRotation_Name(enum_t_value);
  }
  static inline bool SkinRotation_Parse(const std::string& name,
      SkinRotation* value) {
    return Rotation_SkinRotation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kXAxisFieldNumber = 2,
    kYAxisFieldNumber = 3,
    kZAxisFieldNumber = 4,
    kRotationFieldNumber = 1,
  };
  // double xAxis = 2;
  void clear_xaxis();
  double xaxis() const;
  void set_xaxis(double value);
  private:
  double _internal_xaxis() const;
  void _internal_set_xaxis(double value);
  public:

  // double yAxis = 3;
  void clear_yaxis();
  double yaxis() const;
  void set_yaxis(double value);
  private:
  double _internal_yaxis() const;
  void _internal_set_yaxis(double value);
  public:

  // double zAxis = 4;
  void clear_zaxis();
  double zaxis() const;
  void set_zaxis(double value);
  private:
  double _internal_zaxis() const;
  void _internal_set_zaxis(double value);
  public:

  // .android.emulation.control.Rotation.SkinRotation rotation = 1;
  void clear_rotation();
  ::android::emulation::control::Rotation_SkinRotation rotation() const;
  void set_rotation(::android::emulation::control::Rotation_SkinRotation value);
  private:
  ::android::emulation::control::Rotation_SkinRotation _internal_rotation() const;
  void _internal_set_rotation(::android::emulation::control::Rotation_SkinRotation value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.Rotation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double xaxis_;
  double yaxis_;
  double zaxis_;
  int rotation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class PhoneCall :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.PhoneCall) */ {
 public:
  PhoneCall();
  virtual ~PhoneCall();

  PhoneCall(const PhoneCall& from);
  PhoneCall(PhoneCall&& from) noexcept
    : PhoneCall() {
    *this = ::std::move(from);
  }

  inline PhoneCall& operator=(const PhoneCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneCall& operator=(PhoneCall&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhoneCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhoneCall* internal_default_instance() {
    return reinterpret_cast<const PhoneCall*>(
               &_PhoneCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PhoneCall& a, PhoneCall& b) {
    a.Swap(&b);
  }
  inline void Swap(PhoneCall* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhoneCall* New() const final {
    return CreateMaybeMessage<PhoneCall>(nullptr);
  }

  PhoneCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhoneCall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhoneCall& from);
  void MergeFrom(const PhoneCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhoneCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.PhoneCall";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PhoneCall_Operation Operation;
  static constexpr Operation InitCall =
    PhoneCall_Operation_InitCall;
  static constexpr Operation AcceptCall =
    PhoneCall_Operation_AcceptCall;
  static constexpr Operation RejectCallExplicit =
    PhoneCall_Operation_RejectCallExplicit;
  static constexpr Operation RejectCallBusy =
    PhoneCall_Operation_RejectCallBusy;
  static constexpr Operation DisconnectCall =
    PhoneCall_Operation_DisconnectCall;
  static constexpr Operation PlaceCallOnHold =
    PhoneCall_Operation_PlaceCallOnHold;
  static constexpr Operation TakeCallOffHold =
    PhoneCall_Operation_TakeCallOffHold;
  static inline bool Operation_IsValid(int value) {
    return PhoneCall_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    PhoneCall_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    PhoneCall_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    PhoneCall_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return PhoneCall_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return PhoneCall_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(const std::string& name,
      Operation* value) {
    return PhoneCall_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 2,
    kOperationFieldNumber = 1,
  };
  // string number = 2;
  void clear_number();
  const std::string& number() const;
  void set_number(const std::string& value);
  void set_number(std::string&& value);
  void set_number(const char* value);
  void set_number(const char* value, size_t size);
  std::string* mutable_number();
  std::string* release_number();
  void set_allocated_number(std::string* number);
  private:
  const std::string& _internal_number() const;
  void _internal_set_number(const std::string& value);
  std::string* _internal_mutable_number();
  public:

  // .android.emulation.control.PhoneCall.Operation operation = 1;
  void clear_operation();
  ::android::emulation::control::PhoneCall_Operation operation() const;
  void set_operation(::android::emulation::control::PhoneCall_Operation value);
  private:
  ::android::emulation::control::PhoneCall_Operation _internal_operation() const;
  void _internal_set_operation(::android::emulation::control::PhoneCall_Operation value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.PhoneCall)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
  int operation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class PhoneResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.PhoneResponse) */ {
 public:
  PhoneResponse();
  virtual ~PhoneResponse();

  PhoneResponse(const PhoneResponse& from);
  PhoneResponse(PhoneResponse&& from) noexcept
    : PhoneResponse() {
    *this = ::std::move(from);
  }

  inline PhoneResponse& operator=(const PhoneResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneResponse& operator=(PhoneResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhoneResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhoneResponse* internal_default_instance() {
    return reinterpret_cast<const PhoneResponse*>(
               &_PhoneResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PhoneResponse& a, PhoneResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PhoneResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhoneResponse* New() const final {
    return CreateMaybeMessage<PhoneResponse>(nullptr);
  }

  PhoneResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhoneResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhoneResponse& from);
  void MergeFrom(const PhoneResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhoneResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.PhoneResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PhoneResponse_Response Response;
  static constexpr Response OK =
    PhoneResponse_Response_OK;
  static constexpr Response BadOperation =
    PhoneResponse_Response_BadOperation;
  static constexpr Response BadNumber =
    PhoneResponse_Response_BadNumber;
  static constexpr Response InvalidAction =
    PhoneResponse_Response_InvalidAction;
  static constexpr Response ActionFailed =
    PhoneResponse_Response_ActionFailed;
  static constexpr Response RadioOff =
    PhoneResponse_Response_RadioOff;
  static inline bool Response_IsValid(int value) {
    return PhoneResponse_Response_IsValid(value);
  }
  static constexpr Response Response_MIN =
    PhoneResponse_Response_Response_MIN;
  static constexpr Response Response_MAX =
    PhoneResponse_Response_Response_MAX;
  static constexpr int Response_ARRAYSIZE =
    PhoneResponse_Response_Response_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Response_descriptor() {
    return PhoneResponse_Response_descriptor();
  }
  template<typename T>
  static inline const std::string& Response_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Response>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Response_Name.");
    return PhoneResponse_Response_Name(enum_t_value);
  }
  static inline bool Response_Parse(const std::string& name,
      Response* value) {
    return PhoneResponse_Response_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .android.emulation.control.PhoneResponse.Response response = 1;
  void clear_response();
  ::android::emulation::control::PhoneResponse_Response response() const;
  void set_response(::android::emulation::control::PhoneResponse_Response value);
  private:
  ::android::emulation::control::PhoneResponse_Response _internal_response() const;
  void _internal_set_response(::android::emulation::control::PhoneResponse_Response value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.PhoneResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Entry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.Entry) */ {
 public:
  Entry();
  virtual ~Entry();

  Entry(const Entry& from);
  Entry(Entry&& from) noexcept
    : Entry() {
    *this = ::std::move(from);
  }

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entry& operator=(Entry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Entry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Entry* internal_default_instance() {
    return reinterpret_cast<const Entry*>(
               &_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Entry& a, Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(Entry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Entry* New() const final {
    return CreateMaybeMessage<Entry>(nullptr);
  }

  Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Entry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Entry& from);
  void MergeFrom(const Entry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.Entry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.Entry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class EntryList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.EntryList) */ {
 public:
  EntryList();
  virtual ~EntryList();

  EntryList(const EntryList& from);
  EntryList(EntryList&& from) noexcept
    : EntryList() {
    *this = ::std::move(from);
  }

  inline EntryList& operator=(const EntryList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntryList& operator=(EntryList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EntryList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntryList* internal_default_instance() {
    return reinterpret_cast<const EntryList*>(
               &_EntryList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(EntryList& a, EntryList& b) {
    a.Swap(&b);
  }
  inline void Swap(EntryList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntryList* New() const final {
    return CreateMaybeMessage<EntryList>(nullptr);
  }

  EntryList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntryList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EntryList& from);
  void MergeFrom(const EntryList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntryList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.EntryList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .android.emulation.control.Entry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::android::emulation::control::Entry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Entry >*
      mutable_entry();
  private:
  const ::android::emulation::control::Entry& _internal_entry(int index) const;
  ::android::emulation::control::Entry* _internal_add_entry();
  public:
  const ::android::emulation::control::Entry& entry(int index) const;
  ::android::emulation::control::Entry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Entry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:android.emulation.control.EntryList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Entry > entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class EmulatorStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.EmulatorStatus) */ {
 public:
  EmulatorStatus();
  virtual ~EmulatorStatus();

  EmulatorStatus(const EmulatorStatus& from);
  EmulatorStatus(EmulatorStatus&& from) noexcept
    : EmulatorStatus() {
    *this = ::std::move(from);
  }

  inline EmulatorStatus& operator=(const EmulatorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmulatorStatus& operator=(EmulatorStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmulatorStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmulatorStatus* internal_default_instance() {
    return reinterpret_cast<const EmulatorStatus*>(
               &_EmulatorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(EmulatorStatus& a, EmulatorStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(EmulatorStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmulatorStatus* New() const final {
    return CreateMaybeMessage<EmulatorStatus>(nullptr);
  }

  EmulatorStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmulatorStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmulatorStatus& from);
  void MergeFrom(const EmulatorStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmulatorStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.EmulatorStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kVmConfigFieldNumber = 4,
    kHardwareConfigFieldNumber = 5,
    kUptimeFieldNumber = 2,
    kBootedFieldNumber = 3,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .android.emulation.control.VmConfiguration vmConfig = 4;
  bool has_vmconfig() const;
  private:
  bool _internal_has_vmconfig() const;
  public:
  void clear_vmconfig();
  const ::android::emulation::control::VmConfiguration& vmconfig() const;
  ::android::emulation::control::VmConfiguration* release_vmconfig();
  ::android::emulation::control::VmConfiguration* mutable_vmconfig();
  void set_allocated_vmconfig(::android::emulation::control::VmConfiguration* vmconfig);
  private:
  const ::android::emulation::control::VmConfiguration& _internal_vmconfig() const;
  ::android::emulation::control::VmConfiguration* _internal_mutable_vmconfig();
  public:

  // .android.emulation.control.EntryList hardwareConfig = 5;
  bool has_hardwareconfig() const;
  private:
  bool _internal_has_hardwareconfig() const;
  public:
  void clear_hardwareconfig();
  const ::android::emulation::control::EntryList& hardwareconfig() const;
  ::android::emulation::control::EntryList* release_hardwareconfig();
  ::android::emulation::control::EntryList* mutable_hardwareconfig();
  void set_allocated_hardwareconfig(::android::emulation::control::EntryList* hardwareconfig);
  private:
  const ::android::emulation::control::EntryList& _internal_hardwareconfig() const;
  ::android::emulation::control::EntryList* _internal_mutable_hardwareconfig();
  public:

  // uint64 uptime = 2;
  void clear_uptime();
  ::PROTOBUF_NAMESPACE_ID::uint64 uptime() const;
  void set_uptime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_uptime() const;
  void _internal_set_uptime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool booted = 3;
  void clear_booted();
  bool booted() const;
  void set_booted(bool value);
  private:
  bool _internal_booted() const;
  void _internal_set_booted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.EmulatorStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::android::emulation::control::VmConfiguration* vmconfig_;
  ::android::emulation::control::EntryList* hardwareconfig_;
  ::PROTOBUF_NAMESPACE_ID::uint64 uptime_;
  bool booted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class AudioFormat :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.AudioFormat) */ {
 public:
  AudioFormat();
  virtual ~AudioFormat();

  AudioFormat(const AudioFormat& from);
  AudioFormat(AudioFormat&& from) noexcept
    : AudioFormat() {
    *this = ::std::move(from);
  }

  inline AudioFormat& operator=(const AudioFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioFormat& operator=(AudioFormat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioFormat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioFormat* internal_default_instance() {
    return reinterpret_cast<const AudioFormat*>(
               &_AudioFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AudioFormat& a, AudioFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioFormat* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioFormat* New() const final {
    return CreateMaybeMessage<AudioFormat>(nullptr);
  }

  AudioFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioFormat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioFormat& from);
  void MergeFrom(const AudioFormat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioFormat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.AudioFormat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AudioFormat_SampleFormat SampleFormat;
  static constexpr SampleFormat AUD_FMT_U8 =
    AudioFormat_SampleFormat_AUD_FMT_U8;
  static constexpr SampleFormat AUD_FMT_S16 =
    AudioFormat_SampleFormat_AUD_FMT_S16;
  static inline bool SampleFormat_IsValid(int value) {
    return AudioFormat_SampleFormat_IsValid(value);
  }
  static constexpr SampleFormat SampleFormat_MIN =
    AudioFormat_SampleFormat_SampleFormat_MIN;
  static constexpr SampleFormat SampleFormat_MAX =
    AudioFormat_SampleFormat_SampleFormat_MAX;
  static constexpr int SampleFormat_ARRAYSIZE =
    AudioFormat_SampleFormat_SampleFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SampleFormat_descriptor() {
    return AudioFormat_SampleFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& SampleFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SampleFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SampleFormat_Name.");
    return AudioFormat_SampleFormat_Name(enum_t_value);
  }
  static inline bool SampleFormat_Parse(const std::string& name,
      SampleFormat* value) {
    return AudioFormat_SampleFormat_Parse(name, value);
  }

  typedef AudioFormat_Channels Channels;
  static constexpr Channels Mono =
    AudioFormat_Channels_Mono;
  static constexpr Channels Stereo =
    AudioFormat_Channels_Stereo;
  static inline bool Channels_IsValid(int value) {
    return AudioFormat_Channels_IsValid(value);
  }
  static constexpr Channels Channels_MIN =
    AudioFormat_Channels_Channels_MIN;
  static constexpr Channels Channels_MAX =
    AudioFormat_Channels_Channels_MAX;
  static constexpr int Channels_ARRAYSIZE =
    AudioFormat_Channels_Channels_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Channels_descriptor() {
    return AudioFormat_Channels_descriptor();
  }
  template<typename T>
  static inline const std::string& Channels_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Channels>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Channels_Name.");
    return AudioFormat_Channels_Name(enum_t_value);
  }
  static inline bool Channels_Parse(const std::string& name,
      Channels* value) {
    return AudioFormat_Channels_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSamplingRateFieldNumber = 1,
    kChannelsFieldNumber = 2,
    kFormatFieldNumber = 3,
  };
  // uint64 samplingRate = 1;
  void clear_samplingrate();
  ::PROTOBUF_NAMESPACE_ID::uint64 samplingrate() const;
  void set_samplingrate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_samplingrate() const;
  void _internal_set_samplingrate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .android.emulation.control.AudioFormat.Channels channels = 2;
  void clear_channels();
  ::android::emulation::control::AudioFormat_Channels channels() const;
  void set_channels(::android::emulation::control::AudioFormat_Channels value);
  private:
  ::android::emulation::control::AudioFormat_Channels _internal_channels() const;
  void _internal_set_channels(::android::emulation::control::AudioFormat_Channels value);
  public:

  // .android.emulation.control.AudioFormat.SampleFormat format = 3;
  void clear_format();
  ::android::emulation::control::AudioFormat_SampleFormat format() const;
  void set_format(::android::emulation::control::AudioFormat_SampleFormat value);
  private:
  ::android::emulation::control::AudioFormat_SampleFormat _internal_format() const;
  void _internal_set_format(::android::emulation::control::AudioFormat_SampleFormat value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.AudioFormat)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 samplingrate_;
  int channels_;
  int format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class AudioPacket :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.AudioPacket) */ {
 public:
  AudioPacket();
  virtual ~AudioPacket();

  AudioPacket(const AudioPacket& from);
  AudioPacket(AudioPacket&& from) noexcept
    : AudioPacket() {
    *this = ::std::move(from);
  }

  inline AudioPacket& operator=(const AudioPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioPacket& operator=(AudioPacket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioPacket* internal_default_instance() {
    return reinterpret_cast<const AudioPacket*>(
               &_AudioPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(AudioPacket& a, AudioPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioPacket* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioPacket* New() const final {
    return CreateMaybeMessage<AudioPacket>(nullptr);
  }

  AudioPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioPacket& from);
  void MergeFrom(const AudioPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.AudioPacket";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFieldNumber = 3,
    kFormatFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // bytes audio = 3;
  void clear_audio();
  const std::string& audio() const;
  void set_audio(const std::string& value);
  void set_audio(std::string&& value);
  void set_audio(const char* value);
  void set_audio(const void* value, size_t size);
  std::string* mutable_audio();
  std::string* release_audio();
  void set_allocated_audio(std::string* audio);
  private:
  const std::string& _internal_audio() const;
  void _internal_set_audio(const std::string& value);
  std::string* _internal_mutable_audio();
  public:

  // .android.emulation.control.AudioFormat format = 1;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const ::android::emulation::control::AudioFormat& format() const;
  ::android::emulation::control::AudioFormat* release_format();
  ::android::emulation::control::AudioFormat* mutable_format();
  void set_allocated_format(::android::emulation::control::AudioFormat* format);
  private:
  const ::android::emulation::control::AudioFormat& _internal_format() const;
  ::android::emulation::control::AudioFormat* _internal_mutable_format();
  public:

  // uint64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.AudioPacket)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_;
  ::android::emulation::control::AudioFormat* format_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class SmsMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:android.emulation.control.SmsMessage) */ {
 public:
  SmsMessage();
  virtual ~SmsMessage();

  SmsMessage(const SmsMessage& from);
  SmsMessage(SmsMessage&& from) noexcept
    : SmsMessage() {
    *this = ::std::move(from);
  }

  inline SmsMessage& operator=(const SmsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmsMessage& operator=(SmsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SmsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmsMessage* internal_default_instance() {
    return reinterpret_cast<const SmsMessage*>(
               &_SmsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SmsMessage& a, SmsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SmsMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SmsMessage* New() const final {
    return CreateMaybeMessage<SmsMessage>(nullptr);
  }

  SmsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SmsMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SmsMessage& from);
  void MergeFrom(const SmsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmsMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "android.emulation.control.SmsMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_5fcontroller_2eproto);
    return ::descriptor_table_emulator_5fcontroller_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcAddressFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // string srcAddress = 1;
  void clear_srcaddress();
  const std::string& srcaddress() const;
  void set_srcaddress(const std::string& value);
  void set_srcaddress(std::string&& value);
  void set_srcaddress(const char* value);
  void set_srcaddress(const char* value, size_t size);
  std::string* mutable_srcaddress();
  std::string* release_srcaddress();
  void set_allocated_srcaddress(std::string* srcaddress);
  private:
  const std::string& _internal_srcaddress() const;
  void _internal_set_srcaddress(const std::string& value);
  std::string* _internal_mutable_srcaddress();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:android.emulation.control.SmsMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr srcaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_5fcontroller_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VmRunState

// .android.emulation.control.VmRunState.RunState state = 1;
inline void VmRunState::clear_state() {
  state_ = 0;
}
inline ::android::emulation::control::VmRunState_RunState VmRunState::_internal_state() const {
  return static_cast< ::android::emulation::control::VmRunState_RunState >(state_);
}
inline ::android::emulation::control::VmRunState_RunState VmRunState::state() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.VmRunState.state)
  return _internal_state();
}
inline void VmRunState::_internal_set_state(::android::emulation::control::VmRunState_RunState value) {
  
  state_ = value;
}
inline void VmRunState::set_state(::android::emulation::control::VmRunState_RunState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.VmRunState.state)
}

// -------------------------------------------------------------------

// ParameterValue

// repeated float data = 1 [packed = true];
inline int ParameterValue::_internal_data_size() const {
  return data_.size();
}
inline int ParameterValue::data_size() const {
  return _internal_data_size();
}
inline void ParameterValue::clear_data() {
  data_.Clear();
}
inline float ParameterValue::_internal_data(int index) const {
  return data_.Get(index);
}
inline float ParameterValue::data(int index) const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ParameterValue.data)
  return _internal_data(index);
}
inline void ParameterValue::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:android.emulation.control.ParameterValue.data)
}
inline void ParameterValue::_internal_add_data(float value) {
  data_.Add(value);
}
inline void ParameterValue::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:android.emulation.control.ParameterValue.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ParameterValue::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ParameterValue::data() const {
  // @@protoc_insertion_point(field_list:android.emulation.control.ParameterValue.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ParameterValue::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ParameterValue::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:android.emulation.control.ParameterValue.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// PhysicalModelValue

// .android.emulation.control.PhysicalModelValue.PhysicalType target = 1;
inline void PhysicalModelValue::clear_target() {
  target_ = 0;
}
inline ::android::emulation::control::PhysicalModelValue_PhysicalType PhysicalModelValue::_internal_target() const {
  return static_cast< ::android::emulation::control::PhysicalModelValue_PhysicalType >(target_);
}
inline ::android::emulation::control::PhysicalModelValue_PhysicalType PhysicalModelValue::target() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.PhysicalModelValue.target)
  return _internal_target();
}
inline void PhysicalModelValue::_internal_set_target(::android::emulation::control::PhysicalModelValue_PhysicalType value) {
  
  target_ = value;
}
inline void PhysicalModelValue::set_target(::android::emulation::control::PhysicalModelValue_PhysicalType value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.PhysicalModelValue.target)
}

// .android.emulation.control.PhysicalModelValue.State status = 2;
inline void PhysicalModelValue::clear_status() {
  status_ = 0;
}
inline ::android::emulation::control::PhysicalModelValue_State PhysicalModelValue::_internal_status() const {
  return static_cast< ::android::emulation::control::PhysicalModelValue_State >(status_);
}
inline ::android::emulation::control::PhysicalModelValue_State PhysicalModelValue::status() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.PhysicalModelValue.status)
  return _internal_status();
}
inline void PhysicalModelValue::_internal_set_status(::android::emulation::control::PhysicalModelValue_State value) {
  
  status_ = value;
}
inline void PhysicalModelValue::set_status(::android::emulation::control::PhysicalModelValue_State value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.PhysicalModelValue.status)
}

// .android.emulation.control.ParameterValue value = 3;
inline bool PhysicalModelValue::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool PhysicalModelValue::has_value() const {
  return _internal_has_value();
}
inline void PhysicalModelValue::clear_value() {
  if (GetArenaNoVirtual() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::android::emulation::control::ParameterValue& PhysicalModelValue::_internal_value() const {
  const ::android::emulation::control::ParameterValue* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::android::emulation::control::ParameterValue*>(
      &::android::emulation::control::_ParameterValue_default_instance_);
}
inline const ::android::emulation::control::ParameterValue& PhysicalModelValue::value() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.PhysicalModelValue.value)
  return _internal_value();
}
inline ::android::emulation::control::ParameterValue* PhysicalModelValue::release_value() {
  // @@protoc_insertion_point(field_release:android.emulation.control.PhysicalModelValue.value)
  
  ::android::emulation::control::ParameterValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::android::emulation::control::ParameterValue* PhysicalModelValue::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::emulation::control::ParameterValue>(GetArenaNoVirtual());
    value_ = p;
  }
  return value_;
}
inline ::android::emulation::control::ParameterValue* PhysicalModelValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.PhysicalModelValue.value)
  return _internal_mutable_value();
}
inline void PhysicalModelValue::set_allocated_value(::android::emulation::control::ParameterValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.PhysicalModelValue.value)
}

// -------------------------------------------------------------------

// SensorValue

// .android.emulation.control.SensorValue.SensorType target = 1;
inline void SensorValue::clear_target() {
  target_ = 0;
}
inline ::android::emulation::control::SensorValue_SensorType SensorValue::_internal_target() const {
  return static_cast< ::android::emulation::control::SensorValue_SensorType >(target_);
}
inline ::android::emulation::control::SensorValue_SensorType SensorValue::target() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.SensorValue.target)
  return _internal_target();
}
inline void SensorValue::_internal_set_target(::android::emulation::control::SensorValue_SensorType value) {
  
  target_ = value;
}
inline void SensorValue::set_target(::android::emulation::control::SensorValue_SensorType value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.SensorValue.target)
}

// .android.emulation.control.SensorValue.State status = 2;
inline void SensorValue::clear_status() {
  status_ = 0;
}
inline ::android::emulation::control::SensorValue_State SensorValue::_internal_status() const {
  return static_cast< ::android::emulation::control::SensorValue_State >(status_);
}
inline ::android::emulation::control::SensorValue_State SensorValue::status() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.SensorValue.status)
  return _internal_status();
}
inline void SensorValue::_internal_set_status(::android::emulation::control::SensorValue_State value) {
  
  status_ = value;
}
inline void SensorValue::set_status(::android::emulation::control::SensorValue_State value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.SensorValue.status)
}

// .android.emulation.control.ParameterValue value = 3;
inline bool SensorValue::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool SensorValue::has_value() const {
  return _internal_has_value();
}
inline void SensorValue::clear_value() {
  if (GetArenaNoVirtual() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::android::emulation::control::ParameterValue& SensorValue::_internal_value() const {
  const ::android::emulation::control::ParameterValue* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::android::emulation::control::ParameterValue*>(
      &::android::emulation::control::_ParameterValue_default_instance_);
}
inline const ::android::emulation::control::ParameterValue& SensorValue::value() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.SensorValue.value)
  return _internal_value();
}
inline ::android::emulation::control::ParameterValue* SensorValue::release_value() {
  // @@protoc_insertion_point(field_release:android.emulation.control.SensorValue.value)
  
  ::android::emulation::control::ParameterValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::android::emulation::control::ParameterValue* SensorValue::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::emulation::control::ParameterValue>(GetArenaNoVirtual());
    value_ = p;
  }
  return value_;
}
inline ::android::emulation::control::ParameterValue* SensorValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.SensorValue.value)
  return _internal_mutable_value();
}
inline void SensorValue::set_allocated_value(::android::emulation::control::ParameterValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.SensorValue.value)
}

// -------------------------------------------------------------------

// LogMessage

// string contents = 1;
inline void LogMessage::clear_contents() {
  contents_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogMessage::contents() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogMessage.contents)
  return _internal_contents();
}
inline void LogMessage::set_contents(const std::string& value) {
  _internal_set_contents(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogMessage.contents)
}
inline std::string* LogMessage::mutable_contents() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.LogMessage.contents)
  return _internal_mutable_contents();
}
inline const std::string& LogMessage::_internal_contents() const {
  return contents_.GetNoArena();
}
inline void LogMessage::_internal_set_contents(const std::string& value) {
  
  contents_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LogMessage::set_contents(std::string&& value) {
  
  contents_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.LogMessage.contents)
}
inline void LogMessage::set_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  contents_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.LogMessage.contents)
}
inline void LogMessage::set_contents(const char* value, size_t size) {
  
  contents_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.LogMessage.contents)
}
inline std::string* LogMessage::_internal_mutable_contents() {
  
  return contents_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogMessage::release_contents() {
  // @@protoc_insertion_point(field_release:android.emulation.control.LogMessage.contents)
  
  return contents_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_contents(std::string* contents) {
  if (contents != nullptr) {
    
  } else {
    
  }
  contents_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contents);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.LogMessage.contents)
}

// int64 start = 2;
inline void LogMessage::clear_start() {
  start_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogMessage::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogMessage::start() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogMessage.start)
  return _internal_start();
}
inline void LogMessage::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_ = value;
}
inline void LogMessage::set_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogMessage.start)
}

// int64 next = 3;
inline void LogMessage::clear_next() {
  next_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogMessage::_internal_next() const {
  return next_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogMessage::next() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogMessage.next)
  return _internal_next();
}
inline void LogMessage::_internal_set_next(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  next_ = value;
}
inline void LogMessage::set_next(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_next(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogMessage.next)
}

// .android.emulation.control.LogMessage.LogType sort = 4;
inline void LogMessage::clear_sort() {
  sort_ = 0;
}
inline ::android::emulation::control::LogMessage_LogType LogMessage::_internal_sort() const {
  return static_cast< ::android::emulation::control::LogMessage_LogType >(sort_);
}
inline ::android::emulation::control::LogMessage_LogType LogMessage::sort() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogMessage.sort)
  return _internal_sort();
}
inline void LogMessage::_internal_set_sort(::android::emulation::control::LogMessage_LogType value) {
  
  sort_ = value;
}
inline void LogMessage::set_sort(::android::emulation::control::LogMessage_LogType value) {
  _internal_set_sort(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogMessage.sort)
}

// repeated .android.emulation.control.LogcatEntry entries = 5;
inline int LogMessage::_internal_entries_size() const {
  return entries_.size();
}
inline int LogMessage::entries_size() const {
  return _internal_entries_size();
}
inline void LogMessage::clear_entries() {
  entries_.Clear();
}
inline ::android::emulation::control::LogcatEntry* LogMessage::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.LogMessage.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::LogcatEntry >*
LogMessage::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:android.emulation.control.LogMessage.entries)
  return &entries_;
}
inline const ::android::emulation::control::LogcatEntry& LogMessage::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::android::emulation::control::LogcatEntry& LogMessage::entries(int index) const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogMessage.entries)
  return _internal_entries(index);
}
inline ::android::emulation::control::LogcatEntry* LogMessage::_internal_add_entries() {
  return entries_.Add();
}
inline ::android::emulation::control::LogcatEntry* LogMessage::add_entries() {
  // @@protoc_insertion_point(field_add:android.emulation.control.LogMessage.entries)
  return _internal_add_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::LogcatEntry >&
LogMessage::entries() const {
  // @@protoc_insertion_point(field_list:android.emulation.control.LogMessage.entries)
  return entries_;
}

// -------------------------------------------------------------------

// LogcatEntry

// uint64 timestamp = 1;
inline void LogcatEntry::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LogcatEntry::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LogcatEntry::timestamp() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogcatEntry.timestamp)
  return _internal_timestamp();
}
inline void LogcatEntry::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void LogcatEntry::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogcatEntry.timestamp)
}

// uint32 pid = 2;
inline void LogcatEntry::clear_pid() {
  pid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogcatEntry::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogcatEntry::pid() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogcatEntry.pid)
  return _internal_pid();
}
inline void LogcatEntry::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pid_ = value;
}
inline void LogcatEntry::set_pid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogcatEntry.pid)
}

// uint32 tid = 3;
inline void LogcatEntry::clear_tid() {
  tid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogcatEntry::_internal_tid() const {
  return tid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogcatEntry::tid() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogcatEntry.tid)
  return _internal_tid();
}
inline void LogcatEntry::_internal_set_tid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  tid_ = value;
}
inline void LogcatEntry::set_tid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogcatEntry.tid)
}

// .android.emulation.control.LogcatEntry.LogLevel level = 4;
inline void LogcatEntry::clear_level() {
  level_ = 0;
}
inline ::android::emulation::control::LogcatEntry_LogLevel LogcatEntry::_internal_level() const {
  return static_cast< ::android::emulation::control::LogcatEntry_LogLevel >(level_);
}
inline ::android::emulation::control::LogcatEntry_LogLevel LogcatEntry::level() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogcatEntry.level)
  return _internal_level();
}
inline void LogcatEntry::_internal_set_level(::android::emulation::control::LogcatEntry_LogLevel value) {
  
  level_ = value;
}
inline void LogcatEntry::set_level(::android::emulation::control::LogcatEntry_LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogcatEntry.level)
}

// string tag = 5;
inline void LogcatEntry::clear_tag() {
  tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogcatEntry::tag() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogcatEntry.tag)
  return _internal_tag();
}
inline void LogcatEntry::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogcatEntry.tag)
}
inline std::string* LogcatEntry::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.LogcatEntry.tag)
  return _internal_mutable_tag();
}
inline const std::string& LogcatEntry::_internal_tag() const {
  return tag_.GetNoArena();
}
inline void LogcatEntry::_internal_set_tag(const std::string& value) {
  
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LogcatEntry::set_tag(std::string&& value) {
  
  tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.LogcatEntry.tag)
}
inline void LogcatEntry::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.LogcatEntry.tag)
}
inline void LogcatEntry::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.LogcatEntry.tag)
}
inline std::string* LogcatEntry::_internal_mutable_tag() {
  
  return tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogcatEntry::release_tag() {
  // @@protoc_insertion_point(field_release:android.emulation.control.LogcatEntry.tag)
  
  return tag_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogcatEntry::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.LogcatEntry.tag)
}

// string msg = 6;
inline void LogcatEntry::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LogcatEntry::msg() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.LogcatEntry.msg)
  return _internal_msg();
}
inline void LogcatEntry::set_msg(const std::string& value) {
  _internal_set_msg(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.LogcatEntry.msg)
}
inline std::string* LogcatEntry::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.LogcatEntry.msg)
  return _internal_mutable_msg();
}
inline const std::string& LogcatEntry::_internal_msg() const {
  return msg_.GetNoArena();
}
inline void LogcatEntry::_internal_set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LogcatEntry::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.LogcatEntry.msg)
}
inline void LogcatEntry::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.LogcatEntry.msg)
}
inline void LogcatEntry::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.LogcatEntry.msg)
}
inline std::string* LogcatEntry::_internal_mutable_msg() {
  
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogcatEntry::release_msg() {
  // @@protoc_insertion_point(field_release:android.emulation.control.LogcatEntry.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogcatEntry::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.LogcatEntry.msg)
}

// -------------------------------------------------------------------

// VmConfiguration

// .android.emulation.control.VmConfiguration.VmHypervisorType hypervisorType = 1;
inline void VmConfiguration::clear_hypervisortype() {
  hypervisortype_ = 0;
}
inline ::android::emulation::control::VmConfiguration_VmHypervisorType VmConfiguration::_internal_hypervisortype() const {
  return static_cast< ::android::emulation::control::VmConfiguration_VmHypervisorType >(hypervisortype_);
}
inline ::android::emulation::control::VmConfiguration_VmHypervisorType VmConfiguration::hypervisortype() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.VmConfiguration.hypervisorType)
  return _internal_hypervisortype();
}
inline void VmConfiguration::_internal_set_hypervisortype(::android::emulation::control::VmConfiguration_VmHypervisorType value) {
  
  hypervisortype_ = value;
}
inline void VmConfiguration::set_hypervisortype(::android::emulation::control::VmConfiguration_VmHypervisorType value) {
  _internal_set_hypervisortype(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.VmConfiguration.hypervisorType)
}

// int32 numberOfCpuCores = 2;
inline void VmConfiguration::clear_numberofcpucores() {
  numberofcpucores_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VmConfiguration::_internal_numberofcpucores() const {
  return numberofcpucores_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VmConfiguration::numberofcpucores() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.VmConfiguration.numberOfCpuCores)
  return _internal_numberofcpucores();
}
inline void VmConfiguration::_internal_set_numberofcpucores(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  numberofcpucores_ = value;
}
inline void VmConfiguration::set_numberofcpucores(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_numberofcpucores(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.VmConfiguration.numberOfCpuCores)
}

// int64 ramSizeBytes = 3;
inline void VmConfiguration::clear_ramsizebytes() {
  ramsizebytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VmConfiguration::_internal_ramsizebytes() const {
  return ramsizebytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VmConfiguration::ramsizebytes() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.VmConfiguration.ramSizeBytes)
  return _internal_ramsizebytes();
}
inline void VmConfiguration::_internal_set_ramsizebytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  ramsizebytes_ = value;
}
inline void VmConfiguration::set_ramsizebytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ramsizebytes(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.VmConfiguration.ramSizeBytes)
}

// -------------------------------------------------------------------

// ClipData

// string text = 1;
inline void ClipData::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ClipData::text() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ClipData.text)
  return _internal_text();
}
inline void ClipData::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.ClipData.text)
}
inline std::string* ClipData::mutable_text() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.ClipData.text)
  return _internal_mutable_text();
}
inline const std::string& ClipData::_internal_text() const {
  return text_.GetNoArena();
}
inline void ClipData::_internal_set_text(const std::string& value) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ClipData::set_text(std::string&& value) {
  
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.ClipData.text)
}
inline void ClipData::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.ClipData.text)
}
inline void ClipData::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.ClipData.text)
}
inline std::string* ClipData::_internal_mutable_text() {
  
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClipData::release_text() {
  // @@protoc_insertion_point(field_release:android.emulation.control.ClipData.text)
  
  return text_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClipData::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.ClipData.text)
}

// -------------------------------------------------------------------

// Touch

// int32 x = 1;
inline void Touch::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::x() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Touch.x)
  return _internal_x();
}
inline void Touch::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void Touch::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Touch.x)
}

// int32 y = 2;
inline void Touch::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::y() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Touch.y)
  return _internal_y();
}
inline void Touch::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void Touch::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Touch.y)
}

// int32 identifier = 3;
inline void Touch::clear_identifier() {
  identifier_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::_internal_identifier() const {
  return identifier_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::identifier() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Touch.identifier)
  return _internal_identifier();
}
inline void Touch::_internal_set_identifier(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  identifier_ = value;
}
inline void Touch::set_identifier(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_identifier(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Touch.identifier)
}

// int32 pressure = 4;
inline void Touch::clear_pressure() {
  pressure_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::_internal_pressure() const {
  return pressure_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::pressure() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Touch.pressure)
  return _internal_pressure();
}
inline void Touch::_internal_set_pressure(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pressure_ = value;
}
inline void Touch::set_pressure(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Touch.pressure)
}

// int32 touch_major = 5;
inline void Touch::clear_touch_major() {
  touch_major_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::_internal_touch_major() const {
  return touch_major_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::touch_major() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Touch.touch_major)
  return _internal_touch_major();
}
inline void Touch::_internal_set_touch_major(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  touch_major_ = value;
}
inline void Touch::set_touch_major(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_touch_major(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Touch.touch_major)
}

// int32 touch_minor = 6;
inline void Touch::clear_touch_minor() {
  touch_minor_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::_internal_touch_minor() const {
  return touch_minor_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Touch::touch_minor() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Touch.touch_minor)
  return _internal_touch_minor();
}
inline void Touch::_internal_set_touch_minor(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  touch_minor_ = value;
}
inline void Touch::set_touch_minor(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_touch_minor(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Touch.touch_minor)
}

// -------------------------------------------------------------------

// TouchEvent

// repeated .android.emulation.control.Touch touches = 1;
inline int TouchEvent::_internal_touches_size() const {
  return touches_.size();
}
inline int TouchEvent::touches_size() const {
  return _internal_touches_size();
}
inline void TouchEvent::clear_touches() {
  touches_.Clear();
}
inline ::android::emulation::control::Touch* TouchEvent::mutable_touches(int index) {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.TouchEvent.touches)
  return touches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Touch >*
TouchEvent::mutable_touches() {
  // @@protoc_insertion_point(field_mutable_list:android.emulation.control.TouchEvent.touches)
  return &touches_;
}
inline const ::android::emulation::control::Touch& TouchEvent::_internal_touches(int index) const {
  return touches_.Get(index);
}
inline const ::android::emulation::control::Touch& TouchEvent::touches(int index) const {
  // @@protoc_insertion_point(field_get:android.emulation.control.TouchEvent.touches)
  return _internal_touches(index);
}
inline ::android::emulation::control::Touch* TouchEvent::_internal_add_touches() {
  return touches_.Add();
}
inline ::android::emulation::control::Touch* TouchEvent::add_touches() {
  // @@protoc_insertion_point(field_add:android.emulation.control.TouchEvent.touches)
  return _internal_add_touches();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Touch >&
TouchEvent::touches() const {
  // @@protoc_insertion_point(field_list:android.emulation.control.TouchEvent.touches)
  return touches_;
}

// int32 device = 2;
inline void TouchEvent::clear_device() {
  device_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TouchEvent::_internal_device() const {
  return device_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TouchEvent::device() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.TouchEvent.device)
  return _internal_device();
}
inline void TouchEvent::_internal_set_device(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  device_ = value;
}
inline void TouchEvent::set_device(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_device(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.TouchEvent.device)
}

// -------------------------------------------------------------------

// MouseEvent

// int32 x = 1;
inline void MouseEvent::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MouseEvent::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MouseEvent::x() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.MouseEvent.x)
  return _internal_x();
}
inline void MouseEvent::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void MouseEvent::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.MouseEvent.x)
}

// int32 y = 2;
inline void MouseEvent::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MouseEvent::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MouseEvent::y() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.MouseEvent.y)
  return _internal_y();
}
inline void MouseEvent::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void MouseEvent::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.MouseEvent.y)
}

// int32 buttons = 3;
inline void MouseEvent::clear_buttons() {
  buttons_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MouseEvent::_internal_buttons() const {
  return buttons_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MouseEvent::buttons() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.MouseEvent.buttons)
  return _internal_buttons();
}
inline void MouseEvent::_internal_set_buttons(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  buttons_ = value;
}
inline void MouseEvent::set_buttons(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_buttons(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.MouseEvent.buttons)
}

// int32 device = 4;
inline void MouseEvent::clear_device() {
  device_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MouseEvent::_internal_device() const {
  return device_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MouseEvent::device() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.MouseEvent.device)
  return _internal_device();
}
inline void MouseEvent::_internal_set_device(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  device_ = value;
}
inline void MouseEvent::set_device(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_device(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.MouseEvent.device)
}

// -------------------------------------------------------------------

// KeyboardEvent

// .android.emulation.control.KeyboardEvent.KeyCodeType codeType = 1;
inline void KeyboardEvent::clear_codetype() {
  codetype_ = 0;
}
inline ::android::emulation::control::KeyboardEvent_KeyCodeType KeyboardEvent::_internal_codetype() const {
  return static_cast< ::android::emulation::control::KeyboardEvent_KeyCodeType >(codetype_);
}
inline ::android::emulation::control::KeyboardEvent_KeyCodeType KeyboardEvent::codetype() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.KeyboardEvent.codeType)
  return _internal_codetype();
}
inline void KeyboardEvent::_internal_set_codetype(::android::emulation::control::KeyboardEvent_KeyCodeType value) {
  
  codetype_ = value;
}
inline void KeyboardEvent::set_codetype(::android::emulation::control::KeyboardEvent_KeyCodeType value) {
  _internal_set_codetype(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.KeyboardEvent.codeType)
}

// .android.emulation.control.KeyboardEvent.KeyEventType eventType = 2;
inline void KeyboardEvent::clear_eventtype() {
  eventtype_ = 0;
}
inline ::android::emulation::control::KeyboardEvent_KeyEventType KeyboardEvent::_internal_eventtype() const {
  return static_cast< ::android::emulation::control::KeyboardEvent_KeyEventType >(eventtype_);
}
inline ::android::emulation::control::KeyboardEvent_KeyEventType KeyboardEvent::eventtype() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.KeyboardEvent.eventType)
  return _internal_eventtype();
}
inline void KeyboardEvent::_internal_set_eventtype(::android::emulation::control::KeyboardEvent_KeyEventType value) {
  
  eventtype_ = value;
}
inline void KeyboardEvent::set_eventtype(::android::emulation::control::KeyboardEvent_KeyEventType value) {
  _internal_set_eventtype(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.KeyboardEvent.eventType)
}

// int32 keyCode = 3;
inline void KeyboardEvent::clear_keycode() {
  keycode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KeyboardEvent::_internal_keycode() const {
  return keycode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KeyboardEvent::keycode() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.KeyboardEvent.keyCode)
  return _internal_keycode();
}
inline void KeyboardEvent::_internal_set_keycode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  keycode_ = value;
}
inline void KeyboardEvent::set_keycode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_keycode(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.KeyboardEvent.keyCode)
}

// string key = 4;
inline void KeyboardEvent::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KeyboardEvent::key() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.KeyboardEvent.key)
  return _internal_key();
}
inline void KeyboardEvent::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.KeyboardEvent.key)
}
inline std::string* KeyboardEvent::mutable_key() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.KeyboardEvent.key)
  return _internal_mutable_key();
}
inline const std::string& KeyboardEvent::_internal_key() const {
  return key_.GetNoArena();
}
inline void KeyboardEvent::_internal_set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void KeyboardEvent::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.KeyboardEvent.key)
}
inline void KeyboardEvent::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.KeyboardEvent.key)
}
inline void KeyboardEvent::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.KeyboardEvent.key)
}
inline std::string* KeyboardEvent::_internal_mutable_key() {
  
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KeyboardEvent::release_key() {
  // @@protoc_insertion_point(field_release:android.emulation.control.KeyboardEvent.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KeyboardEvent::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.KeyboardEvent.key)
}

// string text = 5;
inline void KeyboardEvent::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KeyboardEvent::text() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.KeyboardEvent.text)
  return _internal_text();
}
inline void KeyboardEvent::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.KeyboardEvent.text)
}
inline std::string* KeyboardEvent::mutable_text() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.KeyboardEvent.text)
  return _internal_mutable_text();
}
inline const std::string& KeyboardEvent::_internal_text() const {
  return text_.GetNoArena();
}
inline void KeyboardEvent::_internal_set_text(const std::string& value) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void KeyboardEvent::set_text(std::string&& value) {
  
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.KeyboardEvent.text)
}
inline void KeyboardEvent::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.KeyboardEvent.text)
}
inline void KeyboardEvent::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.KeyboardEvent.text)
}
inline std::string* KeyboardEvent::_internal_mutable_text() {
  
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KeyboardEvent::release_text() {
  // @@protoc_insertion_point(field_release:android.emulation.control.KeyboardEvent.text)
  
  return text_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KeyboardEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.KeyboardEvent.text)
}

// -------------------------------------------------------------------

// Fingerprint

// bool isTouching = 1;
inline void Fingerprint::clear_istouching() {
  istouching_ = false;
}
inline bool Fingerprint::_internal_istouching() const {
  return istouching_;
}
inline bool Fingerprint::istouching() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Fingerprint.isTouching)
  return _internal_istouching();
}
inline void Fingerprint::_internal_set_istouching(bool value) {
  
  istouching_ = value;
}
inline void Fingerprint::set_istouching(bool value) {
  _internal_set_istouching(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Fingerprint.isTouching)
}

// int32 touchId = 2;
inline void Fingerprint::clear_touchid() {
  touchid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint::_internal_touchid() const {
  return touchid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fingerprint::touchid() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Fingerprint.touchId)
  return _internal_touchid();
}
inline void Fingerprint::_internal_set_touchid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  touchid_ = value;
}
inline void Fingerprint::set_touchid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_touchid(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Fingerprint.touchId)
}

// -------------------------------------------------------------------

// GpsState

// bool passiveUpdate = 1;
inline void GpsState::clear_passiveupdate() {
  passiveupdate_ = false;
}
inline bool GpsState::_internal_passiveupdate() const {
  return passiveupdate_;
}
inline bool GpsState::passiveupdate() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.GpsState.passiveUpdate)
  return _internal_passiveupdate();
}
inline void GpsState::_internal_set_passiveupdate(bool value) {
  
  passiveupdate_ = value;
}
inline void GpsState::set_passiveupdate(bool value) {
  _internal_set_passiveupdate(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.GpsState.passiveUpdate)
}

// double latitude = 2;
inline void GpsState::clear_latitude() {
  latitude_ = 0;
}
inline double GpsState::_internal_latitude() const {
  return latitude_;
}
inline double GpsState::latitude() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.GpsState.latitude)
  return _internal_latitude();
}
inline void GpsState::_internal_set_latitude(double value) {
  
  latitude_ = value;
}
inline void GpsState::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.GpsState.latitude)
}

// double longitude = 3;
inline void GpsState::clear_longitude() {
  longitude_ = 0;
}
inline double GpsState::_internal_longitude() const {
  return longitude_;
}
inline double GpsState::longitude() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.GpsState.longitude)
  return _internal_longitude();
}
inline void GpsState::_internal_set_longitude(double value) {
  
  longitude_ = value;
}
inline void GpsState::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.GpsState.longitude)
}

// double speed = 4;
inline void GpsState::clear_speed() {
  speed_ = 0;
}
inline double GpsState::_internal_speed() const {
  return speed_;
}
inline double GpsState::speed() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.GpsState.speed)
  return _internal_speed();
}
inline void GpsState::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void GpsState::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.GpsState.speed)
}

// double bearing = 5;
inline void GpsState::clear_bearing() {
  bearing_ = 0;
}
inline double GpsState::_internal_bearing() const {
  return bearing_;
}
inline double GpsState::bearing() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.GpsState.bearing)
  return _internal_bearing();
}
inline void GpsState::_internal_set_bearing(double value) {
  
  bearing_ = value;
}
inline void GpsState::set_bearing(double value) {
  _internal_set_bearing(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.GpsState.bearing)
}

// double altitude = 6;
inline void GpsState::clear_altitude() {
  altitude_ = 0;
}
inline double GpsState::_internal_altitude() const {
  return altitude_;
}
inline double GpsState::altitude() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.GpsState.altitude)
  return _internal_altitude();
}
inline void GpsState::_internal_set_altitude(double value) {
  
  altitude_ = value;
}
inline void GpsState::set_altitude(double value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.GpsState.altitude)
}

// int32 satellites = 7;
inline void GpsState::clear_satellites() {
  satellites_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GpsState::_internal_satellites() const {
  return satellites_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GpsState::satellites() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.GpsState.satellites)
  return _internal_satellites();
}
inline void GpsState::_internal_set_satellites(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  satellites_ = value;
}
inline void GpsState::set_satellites(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_satellites(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.GpsState.satellites)
}

// -------------------------------------------------------------------

// BatteryState

// bool hasBattery = 1;
inline void BatteryState::clear_hasbattery() {
  hasbattery_ = false;
}
inline bool BatteryState::_internal_hasbattery() const {
  return hasbattery_;
}
inline bool BatteryState::hasbattery() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.BatteryState.hasBattery)
  return _internal_hasbattery();
}
inline void BatteryState::_internal_set_hasbattery(bool value) {
  
  hasbattery_ = value;
}
inline void BatteryState::set_hasbattery(bool value) {
  _internal_set_hasbattery(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.BatteryState.hasBattery)
}

// bool isPresent = 2;
inline void BatteryState::clear_ispresent() {
  ispresent_ = false;
}
inline bool BatteryState::_internal_ispresent() const {
  return ispresent_;
}
inline bool BatteryState::ispresent() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.BatteryState.isPresent)
  return _internal_ispresent();
}
inline void BatteryState::_internal_set_ispresent(bool value) {
  
  ispresent_ = value;
}
inline void BatteryState::set_ispresent(bool value) {
  _internal_set_ispresent(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.BatteryState.isPresent)
}

// .android.emulation.control.BatteryState.BatteryCharger charger = 3;
inline void BatteryState::clear_charger() {
  charger_ = 0;
}
inline ::android::emulation::control::BatteryState_BatteryCharger BatteryState::_internal_charger() const {
  return static_cast< ::android::emulation::control::BatteryState_BatteryCharger >(charger_);
}
inline ::android::emulation::control::BatteryState_BatteryCharger BatteryState::charger() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.BatteryState.charger)
  return _internal_charger();
}
inline void BatteryState::_internal_set_charger(::android::emulation::control::BatteryState_BatteryCharger value) {
  
  charger_ = value;
}
inline void BatteryState::set_charger(::android::emulation::control::BatteryState_BatteryCharger value) {
  _internal_set_charger(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.BatteryState.charger)
}

// int32 chargeLevel = 4;
inline void BatteryState::clear_chargelevel() {
  chargelevel_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatteryState::_internal_chargelevel() const {
  return chargelevel_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BatteryState::chargelevel() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.BatteryState.chargeLevel)
  return _internal_chargelevel();
}
inline void BatteryState::_internal_set_chargelevel(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  chargelevel_ = value;
}
inline void BatteryState::set_chargelevel(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_chargelevel(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.BatteryState.chargeLevel)
}

// .android.emulation.control.BatteryState.BatteryHealth health = 5;
inline void BatteryState::clear_health() {
  health_ = 0;
}
inline ::android::emulation::control::BatteryState_BatteryHealth BatteryState::_internal_health() const {
  return static_cast< ::android::emulation::control::BatteryState_BatteryHealth >(health_);
}
inline ::android::emulation::control::BatteryState_BatteryHealth BatteryState::health() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.BatteryState.health)
  return _internal_health();
}
inline void BatteryState::_internal_set_health(::android::emulation::control::BatteryState_BatteryHealth value) {
  
  health_ = value;
}
inline void BatteryState::set_health(::android::emulation::control::BatteryState_BatteryHealth value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.BatteryState.health)
}

// .android.emulation.control.BatteryState.BatteryStatus status = 6;
inline void BatteryState::clear_status() {
  status_ = 0;
}
inline ::android::emulation::control::BatteryState_BatteryStatus BatteryState::_internal_status() const {
  return static_cast< ::android::emulation::control::BatteryState_BatteryStatus >(status_);
}
inline ::android::emulation::control::BatteryState_BatteryStatus BatteryState::status() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.BatteryState.status)
  return _internal_status();
}
inline void BatteryState::_internal_set_status(::android::emulation::control::BatteryState_BatteryStatus value) {
  
  status_ = value;
}
inline void BatteryState::set_status(::android::emulation::control::BatteryState_BatteryStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.BatteryState.status)
}

// -------------------------------------------------------------------

// ImageTransport

// .android.emulation.control.ImageTransport.TransportChannel channel = 1;
inline void ImageTransport::clear_channel() {
  channel_ = 0;
}
inline ::android::emulation::control::ImageTransport_TransportChannel ImageTransport::_internal_channel() const {
  return static_cast< ::android::emulation::control::ImageTransport_TransportChannel >(channel_);
}
inline ::android::emulation::control::ImageTransport_TransportChannel ImageTransport::channel() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ImageTransport.channel)
  return _internal_channel();
}
inline void ImageTransport::_internal_set_channel(::android::emulation::control::ImageTransport_TransportChannel value) {
  
  channel_ = value;
}
inline void ImageTransport::set_channel(::android::emulation::control::ImageTransport_TransportChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.ImageTransport.channel)
}

// string handle = 2;
inline void ImageTransport::clear_handle() {
  handle_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ImageTransport::handle() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ImageTransport.handle)
  return _internal_handle();
}
inline void ImageTransport::set_handle(const std::string& value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.ImageTransport.handle)
}
inline std::string* ImageTransport::mutable_handle() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.ImageTransport.handle)
  return _internal_mutable_handle();
}
inline const std::string& ImageTransport::_internal_handle() const {
  return handle_.GetNoArena();
}
inline void ImageTransport::_internal_set_handle(const std::string& value) {
  
  handle_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ImageTransport::set_handle(std::string&& value) {
  
  handle_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.ImageTransport.handle)
}
inline void ImageTransport::set_handle(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  handle_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.ImageTransport.handle)
}
inline void ImageTransport::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.ImageTransport.handle)
}
inline std::string* ImageTransport::_internal_mutable_handle() {
  
  return handle_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ImageTransport::release_handle() {
  // @@protoc_insertion_point(field_release:android.emulation.control.ImageTransport.handle)
  
  return handle_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ImageTransport::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.ImageTransport.handle)
}

// -------------------------------------------------------------------

// ImageFormat

// .android.emulation.control.ImageFormat.ImgFormat format = 1;
inline void ImageFormat::clear_format() {
  format_ = 0;
}
inline ::android::emulation::control::ImageFormat_ImgFormat ImageFormat::_internal_format() const {
  return static_cast< ::android::emulation::control::ImageFormat_ImgFormat >(format_);
}
inline ::android::emulation::control::ImageFormat_ImgFormat ImageFormat::format() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ImageFormat.format)
  return _internal_format();
}
inline void ImageFormat::_internal_set_format(::android::emulation::control::ImageFormat_ImgFormat value) {
  
  format_ = value;
}
inline void ImageFormat::set_format(::android::emulation::control::ImageFormat_ImgFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.ImageFormat.format)
}

// .android.emulation.control.Rotation rotation = 2;
inline bool ImageFormat::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool ImageFormat::has_rotation() const {
  return _internal_has_rotation();
}
inline void ImageFormat::clear_rotation() {
  if (GetArenaNoVirtual() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::android::emulation::control::Rotation& ImageFormat::_internal_rotation() const {
  const ::android::emulation::control::Rotation* p = rotation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::android::emulation::control::Rotation*>(
      &::android::emulation::control::_Rotation_default_instance_);
}
inline const ::android::emulation::control::Rotation& ImageFormat::rotation() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ImageFormat.rotation)
  return _internal_rotation();
}
inline ::android::emulation::control::Rotation* ImageFormat::release_rotation() {
  // @@protoc_insertion_point(field_release:android.emulation.control.ImageFormat.rotation)
  
  ::android::emulation::control::Rotation* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::android::emulation::control::Rotation* ImageFormat::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::emulation::control::Rotation>(GetArenaNoVirtual());
    rotation_ = p;
  }
  return rotation_;
}
inline ::android::emulation::control::Rotation* ImageFormat::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.ImageFormat.rotation)
  return _internal_mutable_rotation();
}
inline void ImageFormat::set_allocated_rotation(::android::emulation::control::Rotation* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.ImageFormat.rotation)
}

// uint32 width = 3;
inline void ImageFormat::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageFormat::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageFormat::width() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ImageFormat.width)
  return _internal_width();
}
inline void ImageFormat::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void ImageFormat::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.ImageFormat.width)
}

// uint32 height = 4;
inline void ImageFormat::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageFormat::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageFormat::height() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ImageFormat.height)
  return _internal_height();
}
inline void ImageFormat::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void ImageFormat::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.ImageFormat.height)
}

// uint32 display = 5;
inline void ImageFormat::clear_display() {
  display_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageFormat::_internal_display() const {
  return display_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ImageFormat::display() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ImageFormat.display)
  return _internal_display();
}
inline void ImageFormat::_internal_set_display(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  display_ = value;
}
inline void ImageFormat::set_display(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_display(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.ImageFormat.display)
}

// .android.emulation.control.ImageTransport transport = 6;
inline bool ImageFormat::_internal_has_transport() const {
  return this != internal_default_instance() && transport_ != nullptr;
}
inline bool ImageFormat::has_transport() const {
  return _internal_has_transport();
}
inline void ImageFormat::clear_transport() {
  if (GetArenaNoVirtual() == nullptr && transport_ != nullptr) {
    delete transport_;
  }
  transport_ = nullptr;
}
inline const ::android::emulation::control::ImageTransport& ImageFormat::_internal_transport() const {
  const ::android::emulation::control::ImageTransport* p = transport_;
  return p != nullptr ? *p : *reinterpret_cast<const ::android::emulation::control::ImageTransport*>(
      &::android::emulation::control::_ImageTransport_default_instance_);
}
inline const ::android::emulation::control::ImageTransport& ImageFormat::transport() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.ImageFormat.transport)
  return _internal_transport();
}
inline ::android::emulation::control::ImageTransport* ImageFormat::release_transport() {
  // @@protoc_insertion_point(field_release:android.emulation.control.ImageFormat.transport)
  
  ::android::emulation::control::ImageTransport* temp = transport_;
  transport_ = nullptr;
  return temp;
}
inline ::android::emulation::control::ImageTransport* ImageFormat::_internal_mutable_transport() {
  
  if (transport_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::emulation::control::ImageTransport>(GetArenaNoVirtual());
    transport_ = p;
  }
  return transport_;
}
inline ::android::emulation::control::ImageTransport* ImageFormat::mutable_transport() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.ImageFormat.transport)
  return _internal_mutable_transport();
}
inline void ImageFormat::set_allocated_transport(::android::emulation::control::ImageTransport* transport) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transport_;
  }
  if (transport) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transport = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transport, submessage_arena);
    }
    
  } else {
    
  }
  transport_ = transport;
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.ImageFormat.transport)
}

// -------------------------------------------------------------------

// Image

// .android.emulation.control.ImageFormat format = 1;
inline bool Image::_internal_has_format() const {
  return this != internal_default_instance() && format_ != nullptr;
}
inline bool Image::has_format() const {
  return _internal_has_format();
}
inline void Image::clear_format() {
  if (GetArenaNoVirtual() == nullptr && format_ != nullptr) {
    delete format_;
  }
  format_ = nullptr;
}
inline const ::android::emulation::control::ImageFormat& Image::_internal_format() const {
  const ::android::emulation::control::ImageFormat* p = format_;
  return p != nullptr ? *p : *reinterpret_cast<const ::android::emulation::control::ImageFormat*>(
      &::android::emulation::control::_ImageFormat_default_instance_);
}
inline const ::android::emulation::control::ImageFormat& Image::format() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Image.format)
  return _internal_format();
}
inline ::android::emulation::control::ImageFormat* Image::release_format() {
  // @@protoc_insertion_point(field_release:android.emulation.control.Image.format)
  
  ::android::emulation::control::ImageFormat* temp = format_;
  format_ = nullptr;
  return temp;
}
inline ::android::emulation::control::ImageFormat* Image::_internal_mutable_format() {
  
  if (format_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::emulation::control::ImageFormat>(GetArenaNoVirtual());
    format_ = p;
  }
  return format_;
}
inline ::android::emulation::control::ImageFormat* Image::mutable_format() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.Image.format)
  return _internal_mutable_format();
}
inline void Image::set_allocated_format(::android::emulation::control::ImageFormat* format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete format_;
  }
  if (format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, format, submessage_arena);
    }
    
  } else {
    
  }
  format_ = format;
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.Image.format)
}

// uint32 width = 2 [deprecated = true];
inline void Image::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Image.width)
  return _internal_width();
}
inline void Image::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void Image::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Image.width)
}

// uint32 height = 3 [deprecated = true];
inline void Image::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Image.height)
  return _internal_height();
}
inline void Image::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void Image::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Image.height)
}

// bytes image = 4;
inline void Image::clear_image() {
  image_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Image::image() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Image.image)
  return _internal_image();
}
inline void Image::set_image(const std::string& value) {
  _internal_set_image(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Image.image)
}
inline std::string* Image::mutable_image() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.Image.image)
  return _internal_mutable_image();
}
inline const std::string& Image::_internal_image() const {
  return image_.GetNoArena();
}
inline void Image::_internal_set_image(const std::string& value) {
  
  image_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Image::set_image(std::string&& value) {
  
  image_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.Image.image)
}
inline void Image::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  image_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.Image.image)
}
inline void Image::set_image(const void* value, size_t size) {
  
  image_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.Image.image)
}
inline std::string* Image::_internal_mutable_image() {
  
  return image_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Image::release_image() {
  // @@protoc_insertion_point(field_release:android.emulation.control.Image.image)
  
  return image_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.Image.image)
}

// uint32 seq = 5;
inline void Image::clear_seq() {
  seq_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::seq() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Image.seq)
  return _internal_seq();
}
inline void Image::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  seq_ = value;
}
inline void Image::set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Image.seq)
}

// uint64 timestampUs = 6;
inline void Image::clear_timestampus() {
  timestampus_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Image::_internal_timestampus() const {
  return timestampus_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Image::timestampus() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Image.timestampUs)
  return _internal_timestampus();
}
inline void Image::_internal_set_timestampus(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestampus_ = value;
}
inline void Image::set_timestampus(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestampus(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Image.timestampUs)
}

// -------------------------------------------------------------------

// Rotation

// .android.emulation.control.Rotation.SkinRotation rotation = 1;
inline void Rotation::clear_rotation() {
  rotation_ = 0;
}
inline ::android::emulation::control::Rotation_SkinRotation Rotation::_internal_rotation() const {
  return static_cast< ::android::emulation::control::Rotation_SkinRotation >(rotation_);
}
inline ::android::emulation::control::Rotation_SkinRotation Rotation::rotation() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Rotation.rotation)
  return _internal_rotation();
}
inline void Rotation::_internal_set_rotation(::android::emulation::control::Rotation_SkinRotation value) {
  
  rotation_ = value;
}
inline void Rotation::set_rotation(::android::emulation::control::Rotation_SkinRotation value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Rotation.rotation)
}

// double xAxis = 2;
inline void Rotation::clear_xaxis() {
  xaxis_ = 0;
}
inline double Rotation::_internal_xaxis() const {
  return xaxis_;
}
inline double Rotation::xaxis() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Rotation.xAxis)
  return _internal_xaxis();
}
inline void Rotation::_internal_set_xaxis(double value) {
  
  xaxis_ = value;
}
inline void Rotation::set_xaxis(double value) {
  _internal_set_xaxis(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Rotation.xAxis)
}

// double yAxis = 3;
inline void Rotation::clear_yaxis() {
  yaxis_ = 0;
}
inline double Rotation::_internal_yaxis() const {
  return yaxis_;
}
inline double Rotation::yaxis() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Rotation.yAxis)
  return _internal_yaxis();
}
inline void Rotation::_internal_set_yaxis(double value) {
  
  yaxis_ = value;
}
inline void Rotation::set_yaxis(double value) {
  _internal_set_yaxis(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Rotation.yAxis)
}

// double zAxis = 4;
inline void Rotation::clear_zaxis() {
  zaxis_ = 0;
}
inline double Rotation::_internal_zaxis() const {
  return zaxis_;
}
inline double Rotation::zaxis() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Rotation.zAxis)
  return _internal_zaxis();
}
inline void Rotation::_internal_set_zaxis(double value) {
  
  zaxis_ = value;
}
inline void Rotation::set_zaxis(double value) {
  _internal_set_zaxis(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Rotation.zAxis)
}

// -------------------------------------------------------------------

// PhoneCall

// .android.emulation.control.PhoneCall.Operation operation = 1;
inline void PhoneCall::clear_operation() {
  operation_ = 0;
}
inline ::android::emulation::control::PhoneCall_Operation PhoneCall::_internal_operation() const {
  return static_cast< ::android::emulation::control::PhoneCall_Operation >(operation_);
}
inline ::android::emulation::control::PhoneCall_Operation PhoneCall::operation() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.PhoneCall.operation)
  return _internal_operation();
}
inline void PhoneCall::_internal_set_operation(::android::emulation::control::PhoneCall_Operation value) {
  
  operation_ = value;
}
inline void PhoneCall::set_operation(::android::emulation::control::PhoneCall_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.PhoneCall.operation)
}

// string number = 2;
inline void PhoneCall::clear_number() {
  number_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PhoneCall::number() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.PhoneCall.number)
  return _internal_number();
}
inline void PhoneCall::set_number(const std::string& value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.PhoneCall.number)
}
inline std::string* PhoneCall::mutable_number() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.PhoneCall.number)
  return _internal_mutable_number();
}
inline const std::string& PhoneCall::_internal_number() const {
  return number_.GetNoArena();
}
inline void PhoneCall::_internal_set_number(const std::string& value) {
  
  number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PhoneCall::set_number(std::string&& value) {
  
  number_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.PhoneCall.number)
}
inline void PhoneCall::set_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.PhoneCall.number)
}
inline void PhoneCall::set_number(const char* value, size_t size) {
  
  number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.PhoneCall.number)
}
inline std::string* PhoneCall::_internal_mutable_number() {
  
  return number_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PhoneCall::release_number() {
  // @@protoc_insertion_point(field_release:android.emulation.control.PhoneCall.number)
  
  return number_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PhoneCall::set_allocated_number(std::string* number) {
  if (number != nullptr) {
    
  } else {
    
  }
  number_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.PhoneCall.number)
}

// -------------------------------------------------------------------

// PhoneResponse

// .android.emulation.control.PhoneResponse.Response response = 1;
inline void PhoneResponse::clear_response() {
  response_ = 0;
}
inline ::android::emulation::control::PhoneResponse_Response PhoneResponse::_internal_response() const {
  return static_cast< ::android::emulation::control::PhoneResponse_Response >(response_);
}
inline ::android::emulation::control::PhoneResponse_Response PhoneResponse::response() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.PhoneResponse.response)
  return _internal_response();
}
inline void PhoneResponse::_internal_set_response(::android::emulation::control::PhoneResponse_Response value) {
  
  response_ = value;
}
inline void PhoneResponse::set_response(::android::emulation::control::PhoneResponse_Response value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.PhoneResponse.response)
}

// -------------------------------------------------------------------

// Entry

// string key = 1;
inline void Entry::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Entry::key() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Entry.key)
  return _internal_key();
}
inline void Entry::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Entry.key)
}
inline std::string* Entry::mutable_key() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.Entry.key)
  return _internal_mutable_key();
}
inline const std::string& Entry::_internal_key() const {
  return key_.GetNoArena();
}
inline void Entry::_internal_set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Entry::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.Entry.key)
}
inline void Entry::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.Entry.key)
}
inline void Entry::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.Entry.key)
}
inline std::string* Entry::_internal_mutable_key() {
  
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Entry::release_key() {
  // @@protoc_insertion_point(field_release:android.emulation.control.Entry.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Entry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.Entry.key)
}

// string value = 2;
inline void Entry::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Entry::value() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.Entry.value)
  return _internal_value();
}
inline void Entry::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.Entry.value)
}
inline std::string* Entry::mutable_value() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.Entry.value)
  return _internal_mutable_value();
}
inline const std::string& Entry::_internal_value() const {
  return value_.GetNoArena();
}
inline void Entry::_internal_set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Entry::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.Entry.value)
}
inline void Entry::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.Entry.value)
}
inline void Entry::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.Entry.value)
}
inline std::string* Entry::_internal_mutable_value() {
  
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Entry::release_value() {
  // @@protoc_insertion_point(field_release:android.emulation.control.Entry.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Entry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.Entry.value)
}

// -------------------------------------------------------------------

// EntryList

// repeated .android.emulation.control.Entry entry = 1;
inline int EntryList::_internal_entry_size() const {
  return entry_.size();
}
inline int EntryList::entry_size() const {
  return _internal_entry_size();
}
inline void EntryList::clear_entry() {
  entry_.Clear();
}
inline ::android::emulation::control::Entry* EntryList::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.EntryList.entry)
  return entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Entry >*
EntryList::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:android.emulation.control.EntryList.entry)
  return &entry_;
}
inline const ::android::emulation::control::Entry& EntryList::_internal_entry(int index) const {
  return entry_.Get(index);
}
inline const ::android::emulation::control::Entry& EntryList::entry(int index) const {
  // @@protoc_insertion_point(field_get:android.emulation.control.EntryList.entry)
  return _internal_entry(index);
}
inline ::android::emulation::control::Entry* EntryList::_internal_add_entry() {
  return entry_.Add();
}
inline ::android::emulation::control::Entry* EntryList::add_entry() {
  // @@protoc_insertion_point(field_add:android.emulation.control.EntryList.entry)
  return _internal_add_entry();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::android::emulation::control::Entry >&
EntryList::entry() const {
  // @@protoc_insertion_point(field_list:android.emulation.control.EntryList.entry)
  return entry_;
}

// -------------------------------------------------------------------

// EmulatorStatus

// string version = 1;
inline void EmulatorStatus::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EmulatorStatus::version() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.EmulatorStatus.version)
  return _internal_version();
}
inline void EmulatorStatus::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.EmulatorStatus.version)
}
inline std::string* EmulatorStatus::mutable_version() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.EmulatorStatus.version)
  return _internal_mutable_version();
}
inline const std::string& EmulatorStatus::_internal_version() const {
  return version_.GetNoArena();
}
inline void EmulatorStatus::_internal_set_version(const std::string& value) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EmulatorStatus::set_version(std::string&& value) {
  
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.EmulatorStatus.version)
}
inline void EmulatorStatus::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.EmulatorStatus.version)
}
inline void EmulatorStatus::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.EmulatorStatus.version)
}
inline std::string* EmulatorStatus::_internal_mutable_version() {
  
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EmulatorStatus::release_version() {
  // @@protoc_insertion_point(field_release:android.emulation.control.EmulatorStatus.version)
  
  return version_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EmulatorStatus::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.EmulatorStatus.version)
}

// uint64 uptime = 2;
inline void EmulatorStatus::clear_uptime() {
  uptime_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EmulatorStatus::_internal_uptime() const {
  return uptime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EmulatorStatus::uptime() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.EmulatorStatus.uptime)
  return _internal_uptime();
}
inline void EmulatorStatus::_internal_set_uptime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  uptime_ = value;
}
inline void EmulatorStatus::set_uptime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_uptime(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.EmulatorStatus.uptime)
}

// bool booted = 3;
inline void EmulatorStatus::clear_booted() {
  booted_ = false;
}
inline bool EmulatorStatus::_internal_booted() const {
  return booted_;
}
inline bool EmulatorStatus::booted() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.EmulatorStatus.booted)
  return _internal_booted();
}
inline void EmulatorStatus::_internal_set_booted(bool value) {
  
  booted_ = value;
}
inline void EmulatorStatus::set_booted(bool value) {
  _internal_set_booted(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.EmulatorStatus.booted)
}

// .android.emulation.control.VmConfiguration vmConfig = 4;
inline bool EmulatorStatus::_internal_has_vmconfig() const {
  return this != internal_default_instance() && vmconfig_ != nullptr;
}
inline bool EmulatorStatus::has_vmconfig() const {
  return _internal_has_vmconfig();
}
inline void EmulatorStatus::clear_vmconfig() {
  if (GetArenaNoVirtual() == nullptr && vmconfig_ != nullptr) {
    delete vmconfig_;
  }
  vmconfig_ = nullptr;
}
inline const ::android::emulation::control::VmConfiguration& EmulatorStatus::_internal_vmconfig() const {
  const ::android::emulation::control::VmConfiguration* p = vmconfig_;
  return p != nullptr ? *p : *reinterpret_cast<const ::android::emulation::control::VmConfiguration*>(
      &::android::emulation::control::_VmConfiguration_default_instance_);
}
inline const ::android::emulation::control::VmConfiguration& EmulatorStatus::vmconfig() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.EmulatorStatus.vmConfig)
  return _internal_vmconfig();
}
inline ::android::emulation::control::VmConfiguration* EmulatorStatus::release_vmconfig() {
  // @@protoc_insertion_point(field_release:android.emulation.control.EmulatorStatus.vmConfig)
  
  ::android::emulation::control::VmConfiguration* temp = vmconfig_;
  vmconfig_ = nullptr;
  return temp;
}
inline ::android::emulation::control::VmConfiguration* EmulatorStatus::_internal_mutable_vmconfig() {
  
  if (vmconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::emulation::control::VmConfiguration>(GetArenaNoVirtual());
    vmconfig_ = p;
  }
  return vmconfig_;
}
inline ::android::emulation::control::VmConfiguration* EmulatorStatus::mutable_vmconfig() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.EmulatorStatus.vmConfig)
  return _internal_mutable_vmconfig();
}
inline void EmulatorStatus::set_allocated_vmconfig(::android::emulation::control::VmConfiguration* vmconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vmconfig_;
  }
  if (vmconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vmconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vmconfig, submessage_arena);
    }
    
  } else {
    
  }
  vmconfig_ = vmconfig;
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.EmulatorStatus.vmConfig)
}

// .android.emulation.control.EntryList hardwareConfig = 5;
inline bool EmulatorStatus::_internal_has_hardwareconfig() const {
  return this != internal_default_instance() && hardwareconfig_ != nullptr;
}
inline bool EmulatorStatus::has_hardwareconfig() const {
  return _internal_has_hardwareconfig();
}
inline void EmulatorStatus::clear_hardwareconfig() {
  if (GetArenaNoVirtual() == nullptr && hardwareconfig_ != nullptr) {
    delete hardwareconfig_;
  }
  hardwareconfig_ = nullptr;
}
inline const ::android::emulation::control::EntryList& EmulatorStatus::_internal_hardwareconfig() const {
  const ::android::emulation::control::EntryList* p = hardwareconfig_;
  return p != nullptr ? *p : *reinterpret_cast<const ::android::emulation::control::EntryList*>(
      &::android::emulation::control::_EntryList_default_instance_);
}
inline const ::android::emulation::control::EntryList& EmulatorStatus::hardwareconfig() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.EmulatorStatus.hardwareConfig)
  return _internal_hardwareconfig();
}
inline ::android::emulation::control::EntryList* EmulatorStatus::release_hardwareconfig() {
  // @@protoc_insertion_point(field_release:android.emulation.control.EmulatorStatus.hardwareConfig)
  
  ::android::emulation::control::EntryList* temp = hardwareconfig_;
  hardwareconfig_ = nullptr;
  return temp;
}
inline ::android::emulation::control::EntryList* EmulatorStatus::_internal_mutable_hardwareconfig() {
  
  if (hardwareconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::emulation::control::EntryList>(GetArenaNoVirtual());
    hardwareconfig_ = p;
  }
  return hardwareconfig_;
}
inline ::android::emulation::control::EntryList* EmulatorStatus::mutable_hardwareconfig() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.EmulatorStatus.hardwareConfig)
  return _internal_mutable_hardwareconfig();
}
inline void EmulatorStatus::set_allocated_hardwareconfig(::android::emulation::control::EntryList* hardwareconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete hardwareconfig_;
  }
  if (hardwareconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hardwareconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hardwareconfig, submessage_arena);
    }
    
  } else {
    
  }
  hardwareconfig_ = hardwareconfig;
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.EmulatorStatus.hardwareConfig)
}

// -------------------------------------------------------------------

// AudioFormat

// uint64 samplingRate = 1;
inline void AudioFormat::clear_samplingrate() {
  samplingrate_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AudioFormat::_internal_samplingrate() const {
  return samplingrate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AudioFormat::samplingrate() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.AudioFormat.samplingRate)
  return _internal_samplingrate();
}
inline void AudioFormat::_internal_set_samplingrate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  samplingrate_ = value;
}
inline void AudioFormat::set_samplingrate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_samplingrate(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.AudioFormat.samplingRate)
}

// .android.emulation.control.AudioFormat.Channels channels = 2;
inline void AudioFormat::clear_channels() {
  channels_ = 0;
}
inline ::android::emulation::control::AudioFormat_Channels AudioFormat::_internal_channels() const {
  return static_cast< ::android::emulation::control::AudioFormat_Channels >(channels_);
}
inline ::android::emulation::control::AudioFormat_Channels AudioFormat::channels() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.AudioFormat.channels)
  return _internal_channels();
}
inline void AudioFormat::_internal_set_channels(::android::emulation::control::AudioFormat_Channels value) {
  
  channels_ = value;
}
inline void AudioFormat::set_channels(::android::emulation::control::AudioFormat_Channels value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.AudioFormat.channels)
}

// .android.emulation.control.AudioFormat.SampleFormat format = 3;
inline void AudioFormat::clear_format() {
  format_ = 0;
}
inline ::android::emulation::control::AudioFormat_SampleFormat AudioFormat::_internal_format() const {
  return static_cast< ::android::emulation::control::AudioFormat_SampleFormat >(format_);
}
inline ::android::emulation::control::AudioFormat_SampleFormat AudioFormat::format() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.AudioFormat.format)
  return _internal_format();
}
inline void AudioFormat::_internal_set_format(::android::emulation::control::AudioFormat_SampleFormat value) {
  
  format_ = value;
}
inline void AudioFormat::set_format(::android::emulation::control::AudioFormat_SampleFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.AudioFormat.format)
}

// -------------------------------------------------------------------

// AudioPacket

// .android.emulation.control.AudioFormat format = 1;
inline bool AudioPacket::_internal_has_format() const {
  return this != internal_default_instance() && format_ != nullptr;
}
inline bool AudioPacket::has_format() const {
  return _internal_has_format();
}
inline void AudioPacket::clear_format() {
  if (GetArenaNoVirtual() == nullptr && format_ != nullptr) {
    delete format_;
  }
  format_ = nullptr;
}
inline const ::android::emulation::control::AudioFormat& AudioPacket::_internal_format() const {
  const ::android::emulation::control::AudioFormat* p = format_;
  return p != nullptr ? *p : *reinterpret_cast<const ::android::emulation::control::AudioFormat*>(
      &::android::emulation::control::_AudioFormat_default_instance_);
}
inline const ::android::emulation::control::AudioFormat& AudioPacket::format() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.AudioPacket.format)
  return _internal_format();
}
inline ::android::emulation::control::AudioFormat* AudioPacket::release_format() {
  // @@protoc_insertion_point(field_release:android.emulation.control.AudioPacket.format)
  
  ::android::emulation::control::AudioFormat* temp = format_;
  format_ = nullptr;
  return temp;
}
inline ::android::emulation::control::AudioFormat* AudioPacket::_internal_mutable_format() {
  
  if (format_ == nullptr) {
    auto* p = CreateMaybeMessage<::android::emulation::control::AudioFormat>(GetArenaNoVirtual());
    format_ = p;
  }
  return format_;
}
inline ::android::emulation::control::AudioFormat* AudioPacket::mutable_format() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.AudioPacket.format)
  return _internal_mutable_format();
}
inline void AudioPacket::set_allocated_format(::android::emulation::control::AudioFormat* format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete format_;
  }
  if (format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, format, submessage_arena);
    }
    
  } else {
    
  }
  format_ = format;
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.AudioPacket.format)
}

// uint64 timestamp = 2;
inline void AudioPacket::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AudioPacket::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AudioPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.AudioPacket.timestamp)
  return _internal_timestamp();
}
inline void AudioPacket::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void AudioPacket::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.AudioPacket.timestamp)
}

// bytes audio = 3;
inline void AudioPacket::clear_audio() {
  audio_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AudioPacket::audio() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.AudioPacket.audio)
  return _internal_audio();
}
inline void AudioPacket::set_audio(const std::string& value) {
  _internal_set_audio(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.AudioPacket.audio)
}
inline std::string* AudioPacket::mutable_audio() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.AudioPacket.audio)
  return _internal_mutable_audio();
}
inline const std::string& AudioPacket::_internal_audio() const {
  return audio_.GetNoArena();
}
inline void AudioPacket::_internal_set_audio(const std::string& value) {
  
  audio_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AudioPacket::set_audio(std::string&& value) {
  
  audio_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.AudioPacket.audio)
}
inline void AudioPacket::set_audio(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audio_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.AudioPacket.audio)
}
inline void AudioPacket::set_audio(const void* value, size_t size) {
  
  audio_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.AudioPacket.audio)
}
inline std::string* AudioPacket::_internal_mutable_audio() {
  
  return audio_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AudioPacket::release_audio() {
  // @@protoc_insertion_point(field_release:android.emulation.control.AudioPacket.audio)
  
  return audio_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AudioPacket::set_allocated_audio(std::string* audio) {
  if (audio != nullptr) {
    
  } else {
    
  }
  audio_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.AudioPacket.audio)
}

// -------------------------------------------------------------------

// SmsMessage

// string srcAddress = 1;
inline void SmsMessage::clear_srcaddress() {
  srcaddress_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SmsMessage::srcaddress() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.SmsMessage.srcAddress)
  return _internal_srcaddress();
}
inline void SmsMessage::set_srcaddress(const std::string& value) {
  _internal_set_srcaddress(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.SmsMessage.srcAddress)
}
inline std::string* SmsMessage::mutable_srcaddress() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.SmsMessage.srcAddress)
  return _internal_mutable_srcaddress();
}
inline const std::string& SmsMessage::_internal_srcaddress() const {
  return srcaddress_.GetNoArena();
}
inline void SmsMessage::_internal_set_srcaddress(const std::string& value) {
  
  srcaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SmsMessage::set_srcaddress(std::string&& value) {
  
  srcaddress_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.SmsMessage.srcAddress)
}
inline void SmsMessage::set_srcaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  srcaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.SmsMessage.srcAddress)
}
inline void SmsMessage::set_srcaddress(const char* value, size_t size) {
  
  srcaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.SmsMessage.srcAddress)
}
inline std::string* SmsMessage::_internal_mutable_srcaddress() {
  
  return srcaddress_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SmsMessage::release_srcaddress() {
  // @@protoc_insertion_point(field_release:android.emulation.control.SmsMessage.srcAddress)
  
  return srcaddress_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SmsMessage::set_allocated_srcaddress(std::string* srcaddress) {
  if (srcaddress != nullptr) {
    
  } else {
    
  }
  srcaddress_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), srcaddress);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.SmsMessage.srcAddress)
}

// string text = 2;
inline void SmsMessage::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SmsMessage::text() const {
  // @@protoc_insertion_point(field_get:android.emulation.control.SmsMessage.text)
  return _internal_text();
}
inline void SmsMessage::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:android.emulation.control.SmsMessage.text)
}
inline std::string* SmsMessage::mutable_text() {
  // @@protoc_insertion_point(field_mutable:android.emulation.control.SmsMessage.text)
  return _internal_mutable_text();
}
inline const std::string& SmsMessage::_internal_text() const {
  return text_.GetNoArena();
}
inline void SmsMessage::_internal_set_text(const std::string& value) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SmsMessage::set_text(std::string&& value) {
  
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:android.emulation.control.SmsMessage.text)
}
inline void SmsMessage::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:android.emulation.control.SmsMessage.text)
}
inline void SmsMessage::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:android.emulation.control.SmsMessage.text)
}
inline std::string* SmsMessage::_internal_mutable_text() {
  
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SmsMessage::release_text() {
  // @@protoc_insertion_point(field_release:android.emulation.control.SmsMessage.text)
  
  return text_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SmsMessage::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:android.emulation.control.SmsMessage.text)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace control
}  // namespace emulation
}  // namespace android

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::android::emulation::control::VmRunState_RunState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::VmRunState_RunState>() {
  return ::android::emulation::control::VmRunState_RunState_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::PhysicalModelValue_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::PhysicalModelValue_State>() {
  return ::android::emulation::control::PhysicalModelValue_State_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::PhysicalModelValue_PhysicalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::PhysicalModelValue_PhysicalType>() {
  return ::android::emulation::control::PhysicalModelValue_PhysicalType_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::SensorValue_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::SensorValue_State>() {
  return ::android::emulation::control::SensorValue_State_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::SensorValue_SensorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::SensorValue_SensorType>() {
  return ::android::emulation::control::SensorValue_SensorType_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::LogMessage_LogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::LogMessage_LogType>() {
  return ::android::emulation::control::LogMessage_LogType_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::LogcatEntry_LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::LogcatEntry_LogLevel>() {
  return ::android::emulation::control::LogcatEntry_LogLevel_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::VmConfiguration_VmHypervisorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::VmConfiguration_VmHypervisorType>() {
  return ::android::emulation::control::VmConfiguration_VmHypervisorType_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::KeyboardEvent_KeyCodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::KeyboardEvent_KeyCodeType>() {
  return ::android::emulation::control::KeyboardEvent_KeyCodeType_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::KeyboardEvent_KeyEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::KeyboardEvent_KeyEventType>() {
  return ::android::emulation::control::KeyboardEvent_KeyEventType_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::BatteryState_BatteryStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::BatteryState_BatteryStatus>() {
  return ::android::emulation::control::BatteryState_BatteryStatus_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::BatteryState_BatteryCharger> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::BatteryState_BatteryCharger>() {
  return ::android::emulation::control::BatteryState_BatteryCharger_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::BatteryState_BatteryHealth> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::BatteryState_BatteryHealth>() {
  return ::android::emulation::control::BatteryState_BatteryHealth_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::ImageTransport_TransportChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::ImageTransport_TransportChannel>() {
  return ::android::emulation::control::ImageTransport_TransportChannel_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::ImageFormat_ImgFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::ImageFormat_ImgFormat>() {
  return ::android::emulation::control::ImageFormat_ImgFormat_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::Rotation_SkinRotation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::Rotation_SkinRotation>() {
  return ::android::emulation::control::Rotation_SkinRotation_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::PhoneCall_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::PhoneCall_Operation>() {
  return ::android::emulation::control::PhoneCall_Operation_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::PhoneResponse_Response> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::PhoneResponse_Response>() {
  return ::android::emulation::control::PhoneResponse_Response_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::AudioFormat_SampleFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::AudioFormat_SampleFormat>() {
  return ::android::emulation::control::AudioFormat_SampleFormat_descriptor();
}
template <> struct is_proto_enum< ::android::emulation::control::AudioFormat_Channels> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::android::emulation::control::AudioFormat_Channels>() {
  return ::android::emulation::control::AudioFormat_Channels_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_emulator_5fcontroller_2eproto
